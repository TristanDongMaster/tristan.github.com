<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>wikies.wan blog</title>
 <link href="/" rel="self"/>
 <link href=""/>
 <updated>2016-01-20T16:23:29+08:00</updated>
 <id></id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>vpalmobile api</title>
   <link href="/2016/01/18/vpalmobile-api/"/>
   <updated>2016-01-18T00:00:00+08:00</updated>
   <id>/2016/01/18/vpalmobile-api</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;vpalmobileui 是以H5收银台为基础开发的一套微型H5前端UI组件库，目前包括的组件有：字体、标题、脚手架、banner、按钮、checkbox、文本输入框、列表、tab页、弹窗。组件在不断完善中……&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;兼容性&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Safari 6+ (Mac)
Chrome 30+ (Windows, Mac, Android, iOS, Linux, Chrome OS)
Firefox 24+ (Windows, Mac, Android, Linux, Firefox OS)
iOS 5+ Safari
Android 2.3+ Browser
Internet Explorer 10+ (Windows, Windows Phone)
UC手机浏览器
QQ手机浏览器
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI效果&lt;/h2&gt;

&lt;p&gt;地址：&lt;a href=&quot;http://wikieswan.github.io/vpalmobileui/&quot;&gt;http://wikieswan.github.io/vpalmobileui/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;api&quot;&gt;API&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;脚手架&lt;/h3&gt;

&lt;p&gt;脚手架的结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;
	&amp;lt;div class=&quot;row&quot;&amp;gt;
		&amp;lt;div class=&quot;col&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;&lt;/code&gt; 为最外层容器；&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;&lt;/code&gt; 为行级；&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;col&quot;&amp;gt;&lt;/code&gt; 为列级。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;&lt;/code&gt; 的宽度是整个屏幕宽度的100%；对于不需要满屏的行，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;row row-padding&quot;&amp;gt;&lt;/code&gt; ，这样横向会有 1rem 的空余。如果这种padding不能满足需求，可以自定义横向padding数值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;col&quot;&amp;gt;&lt;/code&gt; 默认宽度是 100% ；为了适应各种宽度需求，提供了各种百分比宽度的 col ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;col-10
col-20
col-25
col-30
col-33
col-40
col-50
col-60
col-67
col-70
col-75
col-80
col-90
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;脚手架目的是为了适应各种形式的布局。&lt;/p&gt;

&lt;h3 id=&quot;banner&quot;&gt;banner&lt;/h3&gt;

&lt;p&gt;banner 的作用是用来展示必要的通知信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- banner --&amp;gt;
&amp;lt;div class=&quot;row demo-pading-top&quot;&amp;gt;
	&amp;lt;div class=&quot;col&quot;&amp;gt;
		&amp;lt;div class=&quot;banner&quot;&amp;gt;这是一个默认的 banner 条&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;row row-padding demo-pading-top&quot;&amp;gt;
	&amp;lt;div class=&quot;col&quot;&amp;gt;
		&amp;lt;div class=&quot;banner&quot;&amp;gt;这是一个 带横向 padding banner 条&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;页面头部&lt;/h3&gt;

&lt;p&gt;页面的头部，包括标题、返回、操作等区域&lt;/p&gt;

&lt;p&gt;基本用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;head&quot;&amp;gt;
	&amp;lt;span class=&quot;h1&quot;&amp;gt;这是标题&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完整用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;head&quot;&amp;gt;
	&amp;lt;a class=&quot;left-option back&quot;  href=&quot;javascript:window.history.back();&quot;&amp;gt;
		&amp;lt;i class=&quot;icon-chevron icon-chevron-left&quot;&amp;gt;&amp;lt;/i&amp;gt;
	&amp;lt;/a&amp;gt;
	&amp;lt;span class=&quot;h1&quot;&amp;gt;快捷支付&amp;lt;/span&amp;gt;
	&amp;lt;a class=&quot;right-option close&quot;&amp;gt;关闭&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;.left-option .right-option 会在头部左右两侧分别预留出来一块区域，用来做其他业务。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span class=&quot;h1&quot;&amp;gt;快捷支付&amp;lt;/span&amp;gt;&lt;/code&gt; 头部显示的文本， .h1 .h2分别用作大小标题；这里用户可以自己定义文本大小。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;按钮&lt;/h3&gt;

&lt;p&gt;按钮可以用 button 和 a 标签，样式用 .btn&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;button class=&quot;btn btn-default&quot;&amp;gt;这是个按钮 btn-default&amp;lt;/button&amp;gt;

&amp;lt;button class=&quot;btn btn-red&quot;&amp;gt;这是个按钮 btn-red&amp;lt;/button&amp;gt;

&amp;lt;button class=&quot;btn btn-disabled&quot;&amp;gt;这是个按钮 btn-disabled&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;.btn 有3个样式： .btn-default .btn-red .btn-disabled&lt;/p&gt;

&lt;p&gt;.btn 的宽度是父级宽度的100%；所以可以通过控制父级的宽度来设置btn的宽度。&lt;/p&gt;

&lt;p&gt;ps：以下是vpalmobileui JavaScript组件，需要引入vpal.ui.js 文件，它依赖zepto.js、zepto.fx.js、zepto.touch.js;&lt;/p&gt;

&lt;h3 id=&quot;checkbox&quot;&gt;checkbox&lt;/h3&gt;

&lt;p&gt;checkbox 有3种状态，分别是默认、选中、不可用；对应的样式分别是：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.checkkbox-default&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.checkkbox-selected&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.checkkbox-disabled&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;.checkbox&lt;/code&gt; 加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;role=&quot;checkbox&quot;&lt;/code&gt; 属性，可以自动响应用户touch；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;row row-padding&quot;&amp;gt;
	&amp;lt;div class=&quot;col&quot;&amp;gt;
		&amp;lt;div class=&quot;checkbox checkkbox-selected&quot; role=&quot;checkbox&quot;&amp;gt;
			&amp;lt;i class=&quot;icon-tick&quot;&amp;gt;&amp;lt;/i&amp;gt;
		&amp;lt;/div&amp;gt;
		&amp;lt;lable&amp;gt;这是个checkbox&amp;lt;/lable&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;checkbox 对外提供3个js接口：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$.checkbox.get(selector)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;获取某个&lt;code class=&quot;highlighter-rouge&quot;&gt;.checkbox&lt;/code&gt;的值，返回true或者false&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$.checkbox.set(selector,value)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设置某个&lt;code class=&quot;highlighter-rouge&quot;&gt;.checkbox&lt;/code&gt;的值，value是true或者false&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$.checkbox.toggle(selector)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;切换某个&lt;code class=&quot;highlighter-rouge&quot;&gt;.checkbox&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;input-&quot;&gt;input 文本输入&lt;/h3&gt;

&lt;p&gt;文本输入，典型的分为3列和2列两种类型&lt;/p&gt;

&lt;p&gt;2列结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;ipt-controll&quot;&amp;gt;
	&amp;lt;div class=&quot;ipt-holder&quot;&amp;gt;
		&amp;lt;div class=&quot;ipt-2-left&quot;&amp;gt;
			&amp;lt;span&amp;gt;银行卡号&amp;lt;/span&amp;gt;
		&amp;lt;/div&amp;gt;
		&amp;lt;div class=&quot;ipt-2-right&quot;&amp;gt;
			&amp;lt;input class=&quot;v-ipt&quot; type=&quot;tel&quot; id=&quot;cardNo&quot; data-validate=&quot;0&quot;
				placeholder=&quot;请输入您本人信用卡或储蓄卡卡号&quot; /&amp;gt;
			&amp;lt;i class=&quot;icon-delet del hide&quot;&amp;gt;&amp;lt;/i&amp;gt;		
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3列结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;ipt-controll&quot;&amp;gt;
	&amp;lt;div class=&quot;ipt-holder&quot;&amp;gt;
		&amp;lt;div class=&quot;ipt-2-left&quot;&amp;gt;
			&amp;lt;span&amp;gt;支付密码&amp;lt;/span&amp;gt;
		&amp;lt;/div&amp;gt;
		&amp;lt;div class=&quot;ipt-2-right&quot;&amp;gt;
			&amp;lt;input class=&quot;v-ipt&quot; type=&quot;password&quot; id=&quot;payPass&quot;
			placeholder=&quot;请输入支付密码&quot; /&amp;gt;
			&amp;lt;i class=&quot;icon-delet del hide&quot;&amp;gt;&amp;lt;/i&amp;gt;	
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中注意 input 标签有个兄弟节点 i ，这是一个删除用户输入的按钮，可以清除用户输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input class=&quot;v-ipt&quot; type=&quot;password&quot; id=&quot;payPass&quot; placeholder=&quot;请输入支付密码&quot; /&amp;gt;
&amp;lt;i class=&quot;icon-delet del hide&quot;&amp;gt;&amp;lt;/i&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tabs&quot;&gt;tabs页&lt;/h3&gt;

&lt;p&gt;tabs组件由tabs和tab-content组成，具体写法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;tabs&quot;&amp;gt;
	&amp;lt;div data-tab=&quot;left&quot;  class=&quot;tab tab-left active&quot;&amp;gt;信用卡&amp;lt;/div&amp;gt;
	&amp;lt;div data-tab=&quot;right&quot; class=&quot;tab tab-right&quot;&amp;gt;储蓄卡&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;tab-content&quot;&amp;gt;
	&amp;lt;div data-pannel=&quot;left&quot;&amp;gt;
		&amp;lt;div class=&quot;row row-padding&quot;&amp;gt;
			tab 1 内容
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;div data-pannel=&quot;right&quot; class=&quot;hide&quot;&amp;gt;
		&amp;lt;div class=&quot;row row-padding&quot;&amp;gt;
			tab 2 内容
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;list&quot;&gt;list&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;list&quot;&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 1&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item active&quot;&amp;gt;路人甲 2&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 3&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 4&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 5&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 5&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 6&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 7&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;modal&quot;&gt;modal&lt;/h3&gt;

&lt;p&gt;modal弹窗，以右侧向左侧方向进入，关闭时反向。
弹窗有两种方式控制，分别&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在DOM中利用标签属性控制&lt;/p&gt;

    &lt;p&gt;data-modal=”#someFullpageModal” data-action=”show”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;data-modal属性指向弹窗的#id&lt;/p&gt;

&lt;p&gt;data-action表示对modal的操纵类型，有show或者hide&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在js代码中控制&lt;/p&gt;

    &lt;p&gt;$(‘#someFullpageModal’).modal(‘show’);&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$().modal()函数接受一个参数，表示打开或者关闭modal，’show’、’hide’。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;button class=&quot;btn btn-red&quot; id=&quot;openModal&quot; role=&quot;button&quot; &amp;gt;js控制&amp;lt;/button&amp;gt;

&amp;lt;button class=&quot;btn btn-red&quot; role=&quot;button&quot;  data-modal=&quot;#someFullpageModal&quot; data-action=&quot;show&quot;&amp;gt;dom属性控制&amp;lt;/button&amp;gt;

&amp;lt;div class=&quot;modal-fullpage&quot; id=&quot;someFullpageModal&quot; role=&quot;dialog&quot; &amp;gt;
	&amp;lt;div class=&quot;modal-header&quot;&amp;gt;
		&amp;lt;div class=&quot;head&quot;&amp;gt;
			&amp;lt;span class=&quot;h2&quot;&amp;gt;请选择银行卡&amp;lt;/span&amp;gt;
			&amp;lt;a class=&quot;right-option close&quot; role=&quot;button&quot; 
				data-modal=&quot;#someFullpageModal&quot; data-action=&quot;hide&quot;&amp;gt;关闭&amp;lt;/a&amp;gt;
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;modal-body&quot;&amp;gt;
		&amp;lt;div class=&quot;list&quot;&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，第一个&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，最后一个&amp;lt;/div&amp;gt;
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
	$(function(){
		$(&#39;#openModal&#39;).on(&#39;tap&#39;,function(){
			$(&#39;#someFullpageModal&#39;).modal(&#39;show&#39;);
		});
	});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tracetextfntime&quot;&gt;$.trace(text,fn,time)&lt;/h3&gt;

&lt;p&gt;参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;text&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;必须，展示文本&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fn&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;非必须，回调函数&lt;/p&gt;

&lt;p&gt;+time&lt;/p&gt;

&lt;p&gt;非必须，多久后消失弹窗&lt;/p&gt;

&lt;p&gt;小弹框，提示用处。用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//用法1
$.trace(&#39;你好啊！&#39;);

//用法2
$.trace(&#39;带回调函数的弹窗&#39;,function(){
	console.log(&#39;hello world&#39;)
},3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>vpalmobile api</title>
   <link href="/2016/01/18/vpalmobile-api/"/>
   <updated>2016-01-18T00:00:00+08:00</updated>
   <id>/2016/01/18/vpalmobile-api</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;vpalmobileui 是以H5收银台为基础开发的一套微型H5前端UI组件库，目前包括的组件有：字体、标题、脚手架、banner、按钮、checkbox、文本输入框、列表、tab页、弹窗。组件在不断完善中……&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;兼容性&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Safari 6+ (Mac)
Chrome 30+ (Windows, Mac, Android, iOS, Linux, Chrome OS)
Firefox 24+ (Windows, Mac, Android, Linux, Firefox OS)
iOS 5+ Safari
Android 2.3+ Browser
Internet Explorer 10+ (Windows, Windows Phone)
UC手机浏览器
QQ手机浏览器
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI效果&lt;/h2&gt;

&lt;p&gt;地址：&lt;a href=&quot;http://wikieswan.github.io/vpalmobileui/&quot;&gt;http://wikieswan.github.io/vpalmobileui/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;api&quot;&gt;API&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;脚手架&lt;/h3&gt;

&lt;p&gt;脚手架的结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;
	&amp;lt;div class=&quot;row&quot;&amp;gt;
		&amp;lt;div class=&quot;col&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;&lt;/code&gt; 为最外层容器；&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;&lt;/code&gt; 为行级；&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;col&quot;&amp;gt;&lt;/code&gt; 为列级。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;&lt;/code&gt; 的宽度是整个屏幕宽度的100%；对于不需要满屏的行，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;row row-padding&quot;&amp;gt;&lt;/code&gt; ，这样横向会有 1rem 的空余。如果这种padding不能满足需求，可以自定义横向padding数值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;col&quot;&amp;gt;&lt;/code&gt; 默认宽度是 100% ；为了适应各种宽度需求，提供了各种百分比宽度的 col ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;col-10
col-20
col-25
col-30
col-33
col-40
col-50
col-60
col-67
col-70
col-75
col-80
col-90
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;col col-10&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;脚手架目的是为了适应各种形式的布局。&lt;/p&gt;

&lt;h3 id=&quot;banner&quot;&gt;banner&lt;/h3&gt;

&lt;p&gt;banner 的作用是用来展示必要的通知信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- banner --&amp;gt;
&amp;lt;div class=&quot;row demo-pading-top&quot;&amp;gt;
	&amp;lt;div class=&quot;col&quot;&amp;gt;
		&amp;lt;div class=&quot;banner&quot;&amp;gt;这是一个默认的 banner 条&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;row row-padding demo-pading-top&quot;&amp;gt;
	&amp;lt;div class=&quot;col&quot;&amp;gt;
		&amp;lt;div class=&quot;banner&quot;&amp;gt;这是一个 带横向 padding banner 条&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;页面头部&lt;/h3&gt;

&lt;p&gt;页面的头部，包括标题、返回、操作等区域&lt;/p&gt;

&lt;p&gt;基本用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;head&quot;&amp;gt;
	&amp;lt;span class=&quot;h1&quot;&amp;gt;这是标题&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完整用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;head&quot;&amp;gt;
	&amp;lt;a class=&quot;left-option back&quot;  href=&quot;javascript:window.history.back();&quot;&amp;gt;
		&amp;lt;i class=&quot;icon-chevron icon-chevron-left&quot;&amp;gt;&amp;lt;/i&amp;gt;
	&amp;lt;/a&amp;gt;
	&amp;lt;span class=&quot;h1&quot;&amp;gt;快捷支付&amp;lt;/span&amp;gt;
	&amp;lt;a class=&quot;right-option close&quot;&amp;gt;关闭&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;.left-option .right-option 会在头部左右两侧分别预留出来一块区域，用来做其他业务。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span class=&quot;h1&quot;&amp;gt;快捷支付&amp;lt;/span&amp;gt;&lt;/code&gt; 头部显示的文本， .h1 .h2分别用作大小标题；这里用户可以自己定义文本大小。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;按钮&lt;/h3&gt;

&lt;p&gt;按钮可以用 button 和 a 标签，样式用 .btn&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;button class=&quot;btn btn-default&quot;&amp;gt;这是个按钮 btn-default&amp;lt;/button&amp;gt;

&amp;lt;button class=&quot;btn btn-red&quot;&amp;gt;这是个按钮 btn-red&amp;lt;/button&amp;gt;

&amp;lt;button class=&quot;btn btn-disabled&quot;&amp;gt;这是个按钮 btn-disabled&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;.btn 有3个样式： .btn-default .btn-red .btn-disabled&lt;/p&gt;

&lt;p&gt;.btn 的宽度是父级宽度的100%；所以可以通过控制父级的宽度来设置btn的宽度。&lt;/p&gt;

&lt;p&gt;ps：以下是vpalmobileui JavaScript组件，需要引入vpal.ui.js 文件，它依赖zepto.js、zepto.fx.js、zepto.touch.js;&lt;/p&gt;

&lt;h3 id=&quot;checkbox&quot;&gt;checkbox&lt;/h3&gt;

&lt;p&gt;checkbox 有3种状态，分别是默认、选中、不可用；对应的样式分别是：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.checkkbox-default&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.checkkbox-selected&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.checkkbox-disabled&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;.checkbox&lt;/code&gt; 加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;role=&quot;checkbox&quot;&lt;/code&gt; 属性，可以自动响应用户touch；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;row row-padding&quot;&amp;gt;
	&amp;lt;div class=&quot;col&quot;&amp;gt;
		&amp;lt;div class=&quot;checkbox checkkbox-selected&quot; role=&quot;checkbox&quot;&amp;gt;
			&amp;lt;i class=&quot;icon-tick&quot;&amp;gt;&amp;lt;/i&amp;gt;
		&amp;lt;/div&amp;gt;
		&amp;lt;lable&amp;gt;这是个checkbox&amp;lt;/lable&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;checkbox 对外提供3个js接口：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$.checkbox.get(selector)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;获取某个&lt;code class=&quot;highlighter-rouge&quot;&gt;.checkbox&lt;/code&gt;的值，返回true或者false&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$.checkbox.set(selector,value)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设置某个&lt;code class=&quot;highlighter-rouge&quot;&gt;.checkbox&lt;/code&gt;的值，value是true或者false&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$.checkbox.toggle(selector)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;切换某个&lt;code class=&quot;highlighter-rouge&quot;&gt;.checkbox&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;input-&quot;&gt;input 文本输入&lt;/h3&gt;

&lt;p&gt;文本输入，典型的分为3列和2列两种类型&lt;/p&gt;

&lt;p&gt;2列结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;ipt-controll&quot;&amp;gt;
	&amp;lt;div class=&quot;ipt-holder&quot;&amp;gt;
		&amp;lt;div class=&quot;ipt-2-left&quot;&amp;gt;
			&amp;lt;span&amp;gt;银行卡号&amp;lt;/span&amp;gt;
		&amp;lt;/div&amp;gt;
		&amp;lt;div class=&quot;ipt-2-right&quot;&amp;gt;
			&amp;lt;input class=&quot;v-ipt&quot; type=&quot;tel&quot; id=&quot;cardNo&quot; data-validate=&quot;0&quot;
				placeholder=&quot;请输入您本人信用卡或储蓄卡卡号&quot; /&amp;gt;
			&amp;lt;i class=&quot;icon-delet del hide&quot;&amp;gt;&amp;lt;/i&amp;gt;		
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3列结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;ipt-controll&quot;&amp;gt;
	&amp;lt;div class=&quot;ipt-holder&quot;&amp;gt;
		&amp;lt;div class=&quot;ipt-2-left&quot;&amp;gt;
			&amp;lt;span&amp;gt;支付密码&amp;lt;/span&amp;gt;
		&amp;lt;/div&amp;gt;
		&amp;lt;div class=&quot;ipt-2-right&quot;&amp;gt;
			&amp;lt;input class=&quot;v-ipt&quot; type=&quot;password&quot; id=&quot;payPass&quot;
			placeholder=&quot;请输入支付密码&quot; /&amp;gt;
			&amp;lt;i class=&quot;icon-delet del hide&quot;&amp;gt;&amp;lt;/i&amp;gt;	
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中注意 input 标签有个兄弟节点 i ，这是一个删除用户输入的按钮，可以清除用户输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input class=&quot;v-ipt&quot; type=&quot;password&quot; id=&quot;payPass&quot; placeholder=&quot;请输入支付密码&quot; /&amp;gt;
&amp;lt;i class=&quot;icon-delet del hide&quot;&amp;gt;&amp;lt;/i&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tabs&quot;&gt;tabs页&lt;/h3&gt;

&lt;p&gt;tabs组件由tabs和tab-content组成，具体写法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;tabs&quot;&amp;gt;
	&amp;lt;div data-tab=&quot;left&quot;  class=&quot;tab tab-left active&quot;&amp;gt;信用卡&amp;lt;/div&amp;gt;
	&amp;lt;div data-tab=&quot;right&quot; class=&quot;tab tab-right&quot;&amp;gt;储蓄卡&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;tab-content&quot;&amp;gt;
	&amp;lt;div data-pannel=&quot;left&quot;&amp;gt;
		&amp;lt;div class=&quot;row row-padding&quot;&amp;gt;
			tab 1 内容
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;div data-pannel=&quot;right&quot; class=&quot;hide&quot;&amp;gt;
		&amp;lt;div class=&quot;row row-padding&quot;&amp;gt;
			tab 2 内容
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;list&quot;&gt;list&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;list&quot;&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 1&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item active&quot;&amp;gt;路人甲 2&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 3&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 4&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 5&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 5&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 6&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;路人甲 7&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;modal&quot;&gt;modal&lt;/h3&gt;

&lt;p&gt;modal弹窗，以右侧向左侧方向进入，关闭时反向。
弹窗有两种方式控制，分别&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在DOM中利用标签属性控制&lt;/p&gt;

    &lt;p&gt;data-modal=”#someFullpageModal” data-action=”show”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;data-modal属性指向弹窗的#id&lt;/p&gt;

&lt;p&gt;data-action表示对modal的操纵类型，有show或者hide&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在js代码中控制&lt;/p&gt;

    &lt;p&gt;$(‘#someFullpageModal’).modal(‘show’);&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$().modal()函数接受一个参数，表示打开或者关闭modal，’show’、’hide’。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;button class=&quot;btn btn-red&quot; id=&quot;openModal&quot; role=&quot;button&quot; &amp;gt;js控制&amp;lt;/button&amp;gt;

&amp;lt;button class=&quot;btn btn-red&quot; role=&quot;button&quot;  data-modal=&quot;#someFullpageModal&quot; data-action=&quot;show&quot;&amp;gt;dom属性控制&amp;lt;/button&amp;gt;

&amp;lt;div class=&quot;modal-fullpage&quot; id=&quot;someFullpageModal&quot; role=&quot;dialog&quot; &amp;gt;
	&amp;lt;div class=&quot;modal-header&quot;&amp;gt;
		&amp;lt;div class=&quot;head&quot;&amp;gt;
			&amp;lt;span class=&quot;h2&quot;&amp;gt;请选择银行卡&amp;lt;/span&amp;gt;
			&amp;lt;a class=&quot;right-option close&quot; role=&quot;button&quot; 
				data-modal=&quot;#someFullpageModal&quot; data-action=&quot;hide&quot;&amp;gt;关闭&amp;lt;/a&amp;gt;
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;modal-body&quot;&amp;gt;
		&amp;lt;div class=&quot;list&quot;&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，第一个&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，这是个list哦&amp;lt;/div&amp;gt;
			&amp;lt;div class=&quot;item&quot;&amp;gt;新弹窗，最后一个&amp;lt;/div&amp;gt;
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
	$(function(){
		$(&#39;#openModal&#39;).on(&#39;tap&#39;,function(){
			$(&#39;#someFullpageModal&#39;).modal(&#39;show&#39;);
		});
	});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tracetextfntime&quot;&gt;$.trace(text,fn,time)&lt;/h3&gt;

&lt;p&gt;参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;text&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;必须，展示文本&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fn&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;非必须，回调函数&lt;/p&gt;

&lt;p&gt;+time&lt;/p&gt;

&lt;p&gt;非必须，多久后消失弹窗&lt;/p&gt;

&lt;p&gt;小弹框，提示用处。用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//用法1
$.trace(&#39;你好啊！&#39;);

//用法2
$.trace(&#39;带回调函数的弹窗&#39;,function(){
	console.log(&#39;hello world&#39;)
},3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>angularjs performance promote</title>
   <link href="/2015/12/21/angularjs-performance-promote/"/>
   <updated>2015-12-21T00:00:00+08:00</updated>
   <id>/2015/12/21/angularjs-performance-promote</id>
   <content type="html">
&lt;p&gt;angularjs 性能优化&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;脏数据检查 != 轮询检查更新&lt;/h2&gt;

&lt;p&gt;谈起angular的脏检查机制(dirty-checking), 常见的误解就是认为： ng是定时轮询去检查model是否变更。
其实，ng只有在指定事件触发后，才进入$digest cycle：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DOM事件，譬如用户输入文本，点击按钮等。(ng-click)&lt;/li&gt;
  &lt;li&gt;XHR响应事件 ($http)&lt;/li&gt;
  &lt;li&gt;浏览器Location变更事件 ($location)&lt;/li&gt;
  &lt;li&gt;Timer事件($timeout, $interval)&lt;/li&gt;
  &lt;li&gt;执行$digest()或$apply()&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;digestui&quot;&gt;$digest后批量更新UI&lt;/h2&gt;

&lt;p&gt;传统的JS MVC框架, 数据变更是通过setter去触发事件，然后立即更新UI。
而angular则是进入$digest cycle，等待所有model都稳定后，才批量一次性更新UI。
这种机制能减少浏览器repaint次数，从而提高性能。&lt;/p&gt;

&lt;h2 id=&quot;digest-cycle&quot;&gt;提速 $digest cycle&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;关键点&lt;/h3&gt;

&lt;p&gt;尽少的触发$digest (P310)&lt;/p&gt;

&lt;p&gt;尽快的执行$digest&lt;/p&gt;

&lt;h2 id=&quot;watch&quot;&gt;优化$watch&lt;/h2&gt;

&lt;p&gt;$scope.$watch(watchExpression, modelChangeCallback), watchExpression可以是String或Function。
避免watchExpression中执行耗时操作，因为它在每次$digest都会执行1~2次。
避免watchExpression中操作dom，因为它很耗时。
console.log也很耗时，记得发布时干掉它。（用grunt groundskeeper）
ng-if vs ng-show， 前者会移除DOM和对应的watch
及时移除不必要的$watch。（angular自动生成的可以通过下文介绍的bindonce） &amp;gt; 参考《mastering web application development with angularjs》 P303~309&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var unwatch = $scope.$watch(&quot;someKey&quot;, function(newValue, oldValue){
  //do sth...
  if(someCondition){
    //当不需要的时候,及时移除watch
    unwatch();
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;避免深度watch， 即第三个参数为true&lt;/p&gt;

&lt;p&gt;参考《mastering web application development with angularjs》 P313
减少watch的变量长度
如下，angular不会仅对{{variable}}建立watcher，而是对整个p标签。
双括号应该被span包裹，因为watch的是外部element&lt;/p&gt;

&lt;p&gt;参考《mastering web application development with angularjs》 P314&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;plain text other {{variable}} plain text other&amp;lt;/p&amp;gt;
//改为:
&amp;lt;p&amp;gt;plain text other &amp;lt;span ng-bind=&#39;variable&#39;&amp;gt;&amp;lt;/span&amp;gt; plain text other&amp;lt;/p&amp;gt;
//或
&amp;lt;p&amp;gt;plain text other &amp;lt;span&amp;gt;{{variable}}&amp;lt;/span&amp;gt; plain text other&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;apply-vs-digest&quot;&gt;$apply vs $digest&lt;/h3&gt;

&lt;p&gt;$apply会使ng进入$digest cycle, 并从$rootScope开始遍历(深度优先)检查数据变更。
$digest仅会检查该scope和它的子scope，当你确定当前操作仅影响它们时，用$digest可以稍微提升性能。 &amp;gt; 参考《mastering web application development with angularjs》 P308
延迟执行&lt;/p&gt;

&lt;p&gt;一些不必要的操作，放到$timeout里面延迟执行。
如果不涉及数据变更，还可以加上第三个参数false，避免调用$apply。
对时间有要求的，第二个参数可以设置为0。
$http.get(‘http://path/to/url’).success(function(data){
  $scope.name = data.name;
  $timeout(function(){
    //do sth later, such as log
  }, 0, false);
});
$evalAsync vs $timeout
http://stackoverflow.com/questions/17301572/angularjs-evalasync-vs-timeout
directive中执行的$evalAsync， 会在angular操作DOM之后，浏览器渲染之前执行。
controller中执行的$evalAsync， 会在angular操作DOM之前执行，一般不这么用。
而使用$timeout，会在浏览器渲染之后执行。&lt;/p&gt;

&lt;h2 id=&quot;ng-repeat&quot;&gt;优化ng-repeat&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;限制列表个数&lt;/h3&gt;

&lt;p&gt;列表对象的数据转换，在放入scope之前处理。如$scope.dataList = convert(dataFromServer)
可以使用ngInfiniteScroll来做无限滚动。&lt;/p&gt;

&lt;h3 id=&quot;track-by&quot;&gt;使用 track by&lt;/h3&gt;

&lt;p&gt;刷新数据时，我们常这么做：$scope.tasks = data || [];，这会导致angular移除掉所有的DOM，重新创建和渲染。
若优化为ng-repeat=”task in tasks track by task.id后，angular就能复用task对应的原DOM进行更新，减少不必要渲染。
参见：http://www.codelord.net/2014/04/15/improving-ng-repeat-performance-with-track-by&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;使用单次绑定&lt;/h2&gt;

&lt;p&gt;我们都知道angular建议一个页面最多2000个双向绑定，但在列表页面通常很容易超标。
譬如一个滑动到底部加载下页的表格，一行20+个绑定, 展示个100行就超标了。
下图这个只是一个很简单的列表，还不是表格，就已经这么多个了：
scope-binding-src
但其实很多属性显示后是几乎不会变更的， 这时候就没必要双向绑定了。（不知道angular为何不考虑此类场景）
如下图，改为bindonce或angular-once后减少了很多：
scope-binding-once&lt;/p&gt;

&lt;p&gt;update：
1.3.0b10开始支持内建单次绑定, {{::variable}}
设计文档:http://t.cn/RvIYHp9 
commit: http://t.cn/RvIYHpC
目前该特性的性能似乎还有待优化(2x slower)&lt;/p&gt;

&lt;h2 id=&quot;filter&quot;&gt;慎用filter&lt;/h2&gt;

&lt;p&gt;在$digest过程中，filter会执行很多次，至少两次。
所以要避免在filter中执行耗时操作。&lt;/p&gt;

&lt;p&gt;参考《mastering web application development with angularjs》 P136&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;angular.module(&#39;filtersPerf&#39;, []).filter(&#39;double&#39;, function(){
  return function(input) {
    //至少输出两次
    console.log(&#39;Calling double on: &#39;+input);
    return input + input;
  };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以在controller中预先处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//mainCtrl.js
angular.module(&#39;filtersPerf&#39;, []).controller(&#39;mainCtrl&#39;, function($scope, $filter){
  $scope.dataList = $filter(&#39;double&#39;)(dataFromServer);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;慎用事件&lt;/h2&gt;

&lt;p&gt;减少事件广播，使用双向数据绑定或共享service等方法来代替。
$broadcast会遍历scope和它的子scope，而不是只通知注册了该事件的子scope。
一个优化方式是使用$emit, 参见angular/angular.js#4574
1.2.7版本对事件做过一个优化，参见https://github.com/angular/angular.js/blob/master/CHANGELOG.md#127-emoji-clairvoyance-2014-01-03
对高频的事件做缓冲限速，避免触发太频繁。
directive&lt;/p&gt;

&lt;p&gt;跟scope数据无关的操作放在compile阶段，它只执行一次。
除了directive外其他地方，特别是controller里面不要操作dom， 尤其是绑定到scope后，便是灾难。
改变以前使用JQuery那样以DOM为中心的思维，拥抱以数据为中心的思维。参见 &amp;gt; 参见: http://stackoverflow.com/questions/14994391/how-do-i-think-in-angularjs-if-i-have-a-jquery-background &amp;gt; 翻译: http://blog.jobbole.com/46589/&lt;/p&gt;

&lt;h2 id=&quot;batarang&quot;&gt;使用Batarang来分析性能&lt;/h2&gt;

&lt;p&gt;AngularJS Batarang是官方提供的chrome插件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/atian25/blog/issues/5&quot;&gt;https://github.com/atian25/blog/issues/5&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>mac root</title>
   <link href="/2015/12/18/mac-root/"/>
   <updated>2015-12-18T00:00:00+08:00</updated>
   <id>/2015/12/18/mac-root</id>
   <content type="html">
&lt;p&gt;mac 进入root权限&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -s
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;退出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ctrl + d	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>mac install ant</title>
   <link href="/2015/12/18/mac-install-ant/"/>
   <updated>2015-12-18T00:00:00+08:00</updated>
   <id>/2015/12/18/mac-install-ant</id>
   <content type="html">
&lt;p&gt;mac 下安装 ant&lt;/p&gt;

&lt;h2 id=&quot;apache-ant&quot;&gt;1 下载 Apache ant&lt;/h2&gt;

&lt;p&gt;官网下载，在墙外；。在官网下载最新的安装包，那个zip包&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2 解压到某个目录&lt;/h2&gt;

&lt;p&gt;解压到指定的目录，我把它解压到 /usr/local/ 下&lt;/p&gt;

&lt;h2 id=&quot;ant-&quot;&gt;3 配置环境变量指定到 ant 解压目录&lt;/h2&gt;

&lt;p&gt;终端输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加ant 配置信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ANT_HOME=/usr/local/apache-ant-1.9.6  
export PATH=${PATH}:${ANT_HOME}/bin 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;4 测试&lt;/h2&gt;

&lt;p&gt;输入命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ant -verison
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Apache Ant(TM) version 1.9.6 compiled on June 29 2015
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装成功！&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>mac android sdk</title>
   <link href="/2015/12/18/mac-android-sdk/"/>
   <updated>2015-12-18T00:00:00+08:00</updated>
   <id>/2015/12/18/mac-android-sdk</id>
   <content type="html">
&lt;p&gt;mac 安装 android sdk&lt;/p&gt;

&lt;h2 id=&quot;android-sdk&quot;&gt;1 下载android sdk&lt;/h2&gt;

&lt;p&gt;去官网下载 &lt;a href=&quot;http://developer.android.com/sdk/installing/index.html&quot;&gt;http://developer.android.com/sdk/installing/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;找到 dmg 安装包，下载。&lt;/p&gt;

&lt;h2 id=&quot;dmg&quot;&gt;2 安装 .dmg文件&lt;/h2&gt;

&lt;p&gt;点击下一步，直到完成。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;3 配置环境变量&lt;/h2&gt;

&lt;p&gt;1 修改环境变量文件&lt;/p&gt;

&lt;p&gt;打开&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ANDROID_HOME=/Users/wan-mac/Library/Android/sdk
export PATH=$ANDROID_HOME/tools:$PATH
export PATH=$ANDROID_HOME/platform-tools:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中	ANDROID_HOME 是你机器上android本地安装路径，我的是 /Users/wan-mac/Library/Android/sdk&lt;/p&gt;

&lt;p&gt;2 刷新修改&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;检查&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;adb devices
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>Mac Yosemite 开机启动设置80端口转发</title>
   <link href="/2015/12/18/mac-80-forward-to-8080/"/>
   <updated>2015-12-18T00:00:00+08:00</updated>
   <id>/2015/12/18/mac-80-forward-to-8080</id>
   <content type="html">
&lt;p&gt;最近换了Mac系统，启动jetty时，发现80端口不能用:&lt;/p&gt;

&lt;p&gt;2015-01-27 23:06:57.819:WARN::failed SelectChannelConnector@0.0.0.0:80: java.net.SocketException: Permission denied 2015-01-27 23:06:57.820:INFO::Started Ajp13SocketConnector@0.0.0.0:8009 2015-01-27 23:06:57.820:INFO::AJP13 is not a secure protocol. Please protect port 8009 2015-01-27 23:06:57.820:WARN::failed Server@426c87c9: java.net.SocketException: Permission denied java.net.SocketException: Permission denied&lt;/p&gt;

&lt;p&gt;原因是1024以下端口，被Unix系统保留，只能以root权限使用。所以希望能够使用8080来启动jetty，然后访问80端口转向8080，在网上找到的解决方案如下：&lt;/p&gt;

&lt;h2 id=&quot;macos-yosemite-&quot;&gt;方案一：（MacOS Yosemite 下已失效）：&lt;/h2&gt;

&lt;p&gt;mac 端口转发&lt;/p&gt;

&lt;p&gt;》查看当前 ipfw 规则:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ipfw show
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;》port 80 to 8080 forward：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ipfw add 100 fwd 127.0.0.1,8080 tcp from any to any 80 in
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;》清除 ipfw 规则&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo ipfw flush
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;ipfw-&quot;&gt;方案二：更新到 10.10 之后之前使用 ipfw 命令被彻底移除了，以下是例外一个方案（虚拟机设置的端口转发案例，并开机自动加载）。&lt;/h2&gt;

&lt;p&gt;下面的命令都是在 root 用户下执行，推荐执行 sudo -i 之后完成下面的操作
创建文件 /etc/pf.anchors/vbox，添加如下两行，将本地 80，22 端口转发到 8080，8022 端口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rdr pass on lo0 inet proto tcp from any to any port 80 -&amp;gt; 127.0.0.1 port 8080
rdr pass on lo0 inet proto tcp from any to any port 22 -&amp;gt; 127.0.0.1 port 8022
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上红色部分需要注意，OS X 默认有个本地网络端口名字叫 lo0 如果你想通过局域网甚至外网访问 80, 22 端口则还需要按照这个格式添加接入网络的端口。&lt;/p&gt;

&lt;p&gt;BTW: 因为非 root 用户不能使用低端口，例如 22， 80 于是我为了访问虚拟机的 ssh 以及 http 使用 22 和 80 端口，于是将 virtualbox 的端口转发设置为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;宿主机	虚拟机
8022	22
8080	80
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再编辑 /etc/pf.conf 文件，在如下位置添加红色两行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scrub-anchor &quot;com.apple/*&quot;
nat-anchor &quot;com.apple/*&quot;
rdr-anchor &quot;com.apple/*&quot;
rdr-anchor &quot;vbox&quot;
dummynet-anchor &quot;com.apple/*&quot;
anchor &quot;com.apple/*&quot;
load anchor &quot;com.apple&quot; from &quot;/etc/pf.anchors/com.apple&quot;
load anchor &quot;vbox&quot; from &quot;/etc/pf.anchors/vbox&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在可以使用命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pfctl -ef /etc/pf.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试端口转发是否生效
为了实现开机自启动，需要编辑文件 /System/Library/LaunchDaemons/com.apple.pfctl.plist&lt;/p&gt;

&lt;p&gt;找到如下位置，添加一行红字所示，之后重启即可自动设置端口转发&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;string&amp;gt;pfctl&amp;lt;/string&amp;gt;
&amp;lt;string&amp;gt;-e&amp;lt;/string&amp;gt;
&amp;lt;string&amp;gt;-f&amp;lt;/string&amp;gt;
&amp;lt;string&amp;gt;/etc/pf.conf&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原文地址：http://rabbit52.com/2014/desktopos/mac/yosemite-port-forwarding-at-startup&lt;/p&gt;

&lt;p&gt;http://www.danchex.com/?p=67&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>android cli</title>
   <link href="/2015/12/18/android-cli/"/>
   <updated>2015-12-18T00:00:00+08:00</updated>
   <id>/2015/12/18/android-cli</id>
   <content type="html">
&lt;p&gt;android 命令行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;adb devices
//列出可用的设备信息


android
//打开android sdk 管理器,一般用于安装和更新 android 各个版本的 sdk

android list sdk --all
//列出所有可用的 sdk	


android update sdk -u -a -t  1,2,3,10,20,21,22,23
//更新指定的sdk  序号对应上一条命令返回的sdk序号
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>how to use r.js to packet requirejs modules</title>
   <link href="/2015/11/23/how-to-use-rjs-to-packet-requirejs-modules/"/>
   <updated>2015-11-23T00:00:00+08:00</updated>
   <id>/2015/11/23/how-to-use-rjs-to-packet-requirejs-modules</id>
   <content type="html">
&lt;p&gt;这篇文章用来介绍如何用 r.js 给 requirejs 模块打包&lt;/p&gt;

&lt;h2 id=&quot;rjs&quot;&gt;r.js是什么&lt;/h2&gt;

&lt;p&gt;r.js 是一个requirejs 官方推荐打包工具，它的作用是把零散的 define 模块按照 requirejs 的依赖关系打包到一个js文件中，来解决上线代码请求数过多的问题。除此之外，r.js 还可以对整个项目的代码进行优化，比如对js代码ugly、对css代码压缩、加上浏览器厂商前缀等。&lt;/p&gt;

&lt;p&gt;关于打包问题，目前一直有关于 webpacket 和 r.js 打包方式的争论，其实它们的争端在于是否需要把公用模块单独拿出来打包尽量使用304. webpacket的做法是把公用模块打包，这样不同页面公用的模块间会用304加载模块，整体代码量会相对减少。 r.js 是把 requirejs用到的模块都打成一个文件，不去区分是否公用，这样公用的模块就会在不同的js文件中出现，整体代码量会上去，但是整体请求数会下降。
二者都有可取之处，关键看应用场景，是看重请求数的影响还是看重下载的代码量（对应流量）。&lt;/p&gt;

&lt;p&gt;这里就先介绍 r.js 的打包方式吧！&lt;/p&gt;

&lt;p&gt;直接看代码的同学，&lt;a href=&quot;https://github.com/wikieswan/rjs-demo&quot;&gt;进入这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;准备材料&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require.js  
r.js
node
gulp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;项目结构&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;www/
	css/
		main.css
	js/
		app/
			index.js
		mod/
			add.js
			minus.js
		pub/	
			ten.js
	lib/
		require.js
	inde.html
build.js
gulpfile.js
package.json
r.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;工程目录中引入了gulp，引入gulp的目的是为了能在gulpfile中执行build指令，这个不是必须的，但是如果你项目本身就是用的gulp，把build集合到你的gulpfile中会很有用的。记住， gulpfile.js  package.json 这两个文件是非必须的。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;代码结构简介&lt;/h2&gt;

&lt;p&gt;项目中index.html作为文件入口，所有的资源引用来自这里。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//index.html

&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt; rjs demo &lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/css&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;css/main.css&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;rjs demo&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lib/require.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 仅仅在开发环境下使用 require.dev.config.js ，打包后删除引用 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;js/require.dev.config.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- end of require.dev.config.js --&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;js/app/index.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;js/require.dev.config.js 是配置文件，requirejs的配置入口。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//js/require.dev.config.js
requirejs.config({
    baseUrl: &#39;./js/mod&#39;,
    urlArgs: &#39;1.0.0&#39;,
    paths: {
        pub : &#39;../pub&#39;
    },
    shim: {

    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;app/ 是业务逻辑代码文件夹
mod/ pub/ 是模块代码文件夹&lt;/p&gt;

&lt;p&gt;app/index.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//app/index.js
requirejs([&#39;add&#39;,&#39;minus&#39;,&#39;pub/ten&#39;],function(add,minus,ten){
	var a = 1, 
		b = 2;
	var rst0 = add(a,b);
	var rst1 = minus(a,b);
	var rst2 = ten(a);	

	console.log(rst0,rst1,rst2);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出来，index.js引入了 ‘add’,’minus’,’pub/ten’ 这三个文件&lt;/p&gt;

&lt;p&gt;这里就不罗列这3个文件的代码了，看名字就能看出来，分别是加、减、乘以10。&lt;/p&gt;

&lt;p&gt;这时候用浏览器打开，查看浏览器的http请求，可以发现类似下面的形式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;index.html
main.css
require.js
require.dev.config.js
index.js
add.js?1.0.0
minus.js?1.0.0
ten.js?1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中?1.0.0是在配置文件 js/require.dev.config.js 配置的版本号。&lt;/p&gt;

&lt;h2 id=&quot;build&quot;&gt;开始build&lt;/h2&gt;

&lt;p&gt;上面介绍了requirejs项目的情况，接下来我们就准备打包吧。&lt;/p&gt;

&lt;p&gt;打包必须：r.js&lt;/p&gt;

&lt;p&gt;这个文件可以去requirejs官网下载。官网提供两种方式打包，分别是命令行配置和文件配置。&lt;/p&gt;

&lt;p&gt;命令行配置不利于理解，也不利于代码维护，这里我们就讲文件配置打包方式。&lt;/p&gt;

&lt;p&gt;我们再项目的根目录下配置一个buil.js。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//build.js
({
    appDir: &#39;./www&#39;,
    baseUrl: &#39;js/mod&#39;,
    dir: &#39;./build&#39;,
    paths: {
        &#39;pub&#39; : &#39;../pub&#39;,
        &#39;app&#39; : &#39;../app&#39;
    },
    modules: [
        {
            name: &#39;app/index&#39;
        }
    ],
    fileExclusionRegExp: /require.dev.config.js/,
    removeCombined: true,
    optimizeCss: &#39;standard&#39;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里讲解下这几个参数的意义；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;appDir
待打包项目的根目录

baseUrl
js文件的根路径，等价于  js/require.dev.config.js 配置的 baseUrl

dir
rjs打包输出路径

paths
等价于 js/require.dev.config.js 配置的 paths 。模块（modules）的相对目录。

shim
为那些没有使用define()声名依赖关系及设置模块值的模块，配置依赖关系与“浏览器全局”出口的脚本。

fileExclusionRegExp
定义打包过滤的规则，把不需要输出的文件过滤掉。

removeCombined
是否在打包前清空上次生成的代码

optimizeCss
css代码的优化规则，RequireJS Optimizer会自动优化应用程序下的CSS文件。这个参数控制CSS最优化设置。允许的值： “none”, “standard”, “standard.keepLines”, “standard.keepComments”, “standard.keepComments.keepLines”。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在正确配置build.js信息之后，我们需要执行一个命令来打包&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node r.js -o build.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打包之后，在项目根目录下生成 build/	，build/的结构如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css/
	main.css
js/
	app/
		index.js
lib/
	require.js
build.txt	
index.html	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，js/文件夹下就只有 app/index.js 了。build.txt 里面记录了rjs打包规则。&lt;/p&gt;

&lt;p&gt;这时候查看 build/index.html 可以看到请求结果如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;index.html
main.css
require.js
index.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中	 main.css css代码被压缩，index.js 代码合并了所以来的模块代码。&lt;/p&gt;

&lt;p&gt;可以发现，这时候 js/require.dev.config.js 这个文件就没有必要引用了。为什么呢？&lt;/p&gt;

&lt;p&gt;道理是这样的，js/require.dev.config.js 这个文件存在于开发环境 （www/），当html引入了 app/index.js ，js/require.dev.config.js来告诉网页怎么根据 app/index.js 的引用去找到真实的js模块代码 。&lt;/p&gt;

&lt;p&gt;当打包完成之后，所以 app/index.js 依赖的模块都被打包进去了，已经完成了代码的注入了，所以就不需要依赖 js/require.dev.config.js 来寻址其他模块了 ，所以说打包后就不再需要引入了 。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;结论&lt;/h2&gt;

&lt;p&gt;可以看到，打包后请求数显著下降了，整个工程的代码也都被优化了。&lt;/p&gt;

&lt;h2 id=&quot;gulprjs-build&quot;&gt;如何在gulp中执行rjs build命令&lt;/h2&gt;

&lt;p&gt;rjs 的打包命令是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node r.js -o build.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们只需要在gulpfile.js执行这条语句就好了 。代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;)
var exec = require(&#39;child_process&#39;).exec;

gulp.task(&#39;rjsBuild&#39;, function(cb) {
    exec(&#39;node r.js -o build.js&#39;, function (err, stdout, stderr) {
        console.log(stdout);
        console.log(stderr);
        cb(err);
    });
    
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里解释下，如果需要在gulpfile.js 中执行任意 node 语句 ，需要引入 require(‘child_process’).exec 模块，这是node 自己的模块，不需要借助其他gulp插件。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;完&lt;/h2&gt;

</content>
 </entry>
 
 <entry>
   <title>nginx mac </title>
   <link href="/2015/10/25/nginx/"/>
   <updated>2015-10-25T00:00:00+08:00</updated>
   <id>/2015/10/25/nginx</id>
   <content type="html">
&lt;h2 id=&quot;macnginx&quot;&gt;在Mac上安装nginx&lt;/h2&gt;

&lt;p&gt;首先，你得安装好homebrew.&lt;/p&gt;

&lt;p&gt;然后在命令行终端执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;….
通过homebrew，nginx默认被安装在&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/Cellar/nginx/1.6.2&lt;/code&gt;, conf文件默认被安装在&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/etc/nginx/nginx.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后再浏览器中键入http://localhost:8080,即可访问到nginx的欢迎界面。&lt;/p&gt;

&lt;p&gt;在开发过程中，我们可能还期望将端口去掉，绑定域名提供测试。&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;p&gt;创建新的目录&lt;code class=&quot;highlighter-rouge&quot;&gt;conf.d，/usr/local/etc/nginx/conf.d&lt;/code&gt;
创建单个服务所需的conf文件default.conf，/usr/local/etc/nginx/conf.d/default.conf
然后将nginx的主文件nginx.conf中的server{}删除，替换成 &lt;code class=&quot;highlighter-rouge&quot;&gt;include /usr/local/etc/nginx/conf.d/*.conf&lt;/code&gt;, nginx将可以加载存放在conf.d目录下的所有conf文件了。
sudo重启nginx。&lt;/p&gt;

&lt;p&gt;如果遇到不能访问的情况，请前往nginx log目录：/usr/local/var/log/nginx/*.log，查看原因。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://maiyang.github.io/mac/nginx/install/2015/07/22/install-nginx-mac/&quot;&gt;http://maiyang.github.io/mac/nginx/install/2015/07/22/install-nginx-mac/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;nginx-&quot;&gt;nginx 命令&lt;/h2&gt;

&lt;p&gt;1、查看nginx进程&lt;/p&gt;

&lt;p&gt;1
	ps -ef|grep nginx&lt;/p&gt;

&lt;p&gt;说明：nginx的进程由主进程和工作进程组成。&lt;/p&gt;

&lt;p&gt;2、启动nginx&lt;/p&gt;

&lt;p&gt;1
	nginx&lt;/p&gt;

&lt;p&gt;启动结果显示nginx的主线程和工作线程，工作线程的数量跟nginx.conf中的配置参数worker_processes有关。&lt;/p&gt;

&lt;p&gt;3、平滑启动nginx&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kill -HUP `cat /var/run/nginx.pid` 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nginx -s reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中进程文件路径在配置文件nginx.conf中可以找到。&lt;/p&gt;

&lt;p&gt;平滑启动的意思是在不停止nginx的情况下，重启nginx，重新加载配置文件，启动新的工作线程，完美停止旧的工作线程。&lt;/p&gt;

&lt;p&gt;4、完美停止nginx&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kill -QUIT `cat /var/run/nginx.pid`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5、快速停止nginx&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kill -TERM `cat /var/run/nginx.pid`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kill -INT `cat /var/run/nginx.pid`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6、完美停止工作进程（主要用于平滑升级）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kill -WINCH `cat /var/run/nginx.pid`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7、强制停止nginx&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pkill -9 nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8、检查对nginx.conf文件的修改是否正确&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nginx -t -c /etc/nginx/nginx.conf 或者 nginx -t
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;9、停止nginx的命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nginx -s stop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;10、查看nginx的版本信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nginx -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;11、查看完整的nginx的配置信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nginx -V nginx -V
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>关闭 Mac 版 Chrome 自动更新的方法</title>
   <link href="/2015/10/20/mac-shout-down-chrome-update/"/>
   <updated>2015-10-20T00:00:00+08:00</updated>
   <id>/2015/10/20/mac-shout-down-chrome-update</id>
   <content type="html">
&lt;p&gt;Chrome 的一大特性之一就是自动更新，但如果在某些特定情况下想要关闭自动更新功能的话，也是可以实现的，本文就分享下如何关闭 Mac 版 Chrome 的自动更新功能。非常简单，在终端中执行命令（然后重启 Chrome）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults write com.google.Keystone.Agent checkInterval 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完成之后，Mac 版 Chrome 就不会在自动更新了，比如你使用3G上网卡，想要节省流量的话，这个方法非常有效。并且需要提醒的是，执行这个命令之后不仅仅会关闭 Chrome 的自动更新功能，还会关闭装在当前电脑上所有 Google 软件的自动更新功能。所以，一般情况下不建议使用。&lt;/p&gt;

&lt;p&gt;关闭自动更新之后，能否手动更新呢？当然！在 Finder 中按快捷键 Command+shift+G，然后输入下面的路径：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/Library/Google/GoogleSoftwareUpdate/GoogleSoftwareUpdate.bundle/Contents/Resources/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着双击该目录中的 CheckForUpdatesNow.command 文件，让它在终端中执行，现在就启动 Google 软件的手动更新功能了。&lt;/p&gt;

&lt;p&gt;如果想要恢复 Chrome 的自动更新也很简单，在终端中运行下面的命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults write com.google.Keystone.Agent checkInterval 18000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原文链接
http://www.chromi.org/archives/13955&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>浏览器跨域问题总结</title>
   <link href="/2015/09/30/cross-origin-methods/"/>
   <updated>2015-09-30T00:00:00+08:00</updated>
   <id>/2015/09/30/cross-origin-methods</id>
   <content type="html">
&lt;h1 id=&quot;section&quot;&gt;浏览器跨域问题总结&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;什么是跨域？&lt;/h2&gt;
&lt;p&gt;概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。&lt;/p&gt;

&lt;p&gt;URL                      	说明       				是否允许通信
http://www.a.com/a.js
http://www.a.com/b.js     	同一域名下   				允许
http://www.a.com/lab/a.js
http://www.a.com/script/b.js 同一域名下不同文件夹 		允许
http://www.a.com:8000/a.js
http://www.a.com/b.js     	同一域名，不同端口  		不允许
http://www.a.com/a.js
https://www.a.com/b.js 		同一域名，不同协议 			不允许
http://www.a.com/a.js
http://70.32.92.74/b.js 	域名和域名对应ip 			不允许
http://www.a.com/a.js
http://script.a.com/b.js 	主域相同，子域不同 			不允许
http://www.a.com/a.js
http://a.com/b.js 			同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）
http://www.cnblogs.com/a.js
http://www.a.com/b.js 		不同域名 					不允许&lt;/p&gt;

&lt;p&gt;解决方案：&lt;/p&gt;

&lt;h2 id=&quot;cors&quot;&gt;跨域资源共享（CORS）&lt;/h2&gt;

&lt;p&gt;CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。
服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
只需要在服务器端设置，客户端普通的js代码就ok。 如何设置，参考 &lt;a href=&quot;http://enable-cors.org/server.html&quot;&gt;http://enable-cors.org/server.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;优点&lt;/p&gt;

&lt;p&gt;JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。&lt;/p&gt;

&lt;p&gt;使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。&lt;/p&gt;

&lt;p&gt;支持cookie&lt;/p&gt;

&lt;p&gt;缺点&lt;/p&gt;

&lt;p&gt;兼容性 ： JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS（这部分会在后文浏览器支持部分介绍）。
具体参考 https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&lt;/p&gt;

&lt;h2 id=&quot;jsonp&quot;&gt;通过jsonp跨域&lt;/h2&gt;

&lt;p&gt;JSONP也叫填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如：&lt;/p&gt;

&lt;p&gt;callback({“name”,”trigkit4”});
JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。&lt;/p&gt;

&lt;p&gt;JSONP的优缺点&lt;/p&gt;

&lt;p&gt;JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。&lt;/p&gt;

&lt;p&gt;JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。&lt;/p&gt;

&lt;h2 id=&quot;documentdomain&quot;&gt;通过修改document.domain来跨子域&lt;/h2&gt;

&lt;p&gt;修改document.domain的方法只适用于不同子域的框架间的交互。&lt;/p&gt;

&lt;p&gt;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&lt;/p&gt;

&lt;p&gt;优点 不需要改动服务器端代码，就可以完成跨域自然解决&lt;/p&gt;

&lt;p&gt;缺点 仅限二级域名不一样的情况 兼容性&lt;/p&gt;

&lt;h2 id=&quot;cross-origin-data-storage-access&quot;&gt;本地存储 Cross-origin data storage access&lt;/h2&gt;

&lt;p&gt;Access to data stored in the browser such as localStorage and IndexedDB are separated by origin. Each origin gets its own separate storage, and JavaScript in one origin cannot read from or write to the storage belonging to another origin.&lt;/p&gt;

&lt;p&gt;使用localStorage等浏览器本地存储进行跨域数据传递&lt;/p&gt;

&lt;p&gt;优点 hack精神
缺点 代码可读性 兼容性&lt;/p&gt;

&lt;h2 id=&quot;api-cross-origin-script-api-access&quot;&gt;跨域标签API Cross-origin script API access&lt;/h2&gt;

&lt;p&gt;JavaScript APIs such as iframe.contentWindow, window.parent, window.open and window.opener allow documents to directly reference each other. When the two documents do not have the same origin, these references provide very limited access to Window and Location objects, as described in the next two sections.&lt;/p&gt;

&lt;p&gt;优点 比较老的解决方案，稳定，兼容性ok
缺点 代码啰嗦&lt;/p&gt;

&lt;h2 id=&quot;windowpostmessage&quot;&gt;window.postMessage&lt;/h2&gt;

&lt;p&gt;window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。&lt;/p&gt;

&lt;p&gt;优点 跨域页面间自由传递消息
缺点 兼容性&lt;/p&gt;

&lt;p&gt;参考&lt;/p&gt;

&lt;p&gt;http://blog.smdcn.net/article/1386.html&lt;/p&gt;

&lt;p&gt;http://segmentfault.com/a/1190000000718840&lt;/p&gt;

&lt;p&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&lt;/p&gt;

&lt;p&gt;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&lt;/p&gt;

&lt;p&gt;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>团建游记</title>
   <link href="/2015/08/07/teambuild/"/>
   <updated>2015-08-07T00:00:00+08:00</updated>
   <id>/2015/08/07/teambuild</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;团建游记&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;团建概览&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbIMG_6821.JPG&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给位看官，注意画面中的表情哈！&lt;/p&gt;

&lt;p&gt;@水民，为什么要这么Q啊！&lt;/p&gt;

&lt;p&gt;@剑清，这么严肃干嘛！&lt;/p&gt;

&lt;p&gt;@乔治，谐星，不能停！&lt;/p&gt;

&lt;p&gt;@建军，发型飘逸的不要不要的！&lt;/p&gt;

&lt;p&gt;总结：水民或成最大赢家！&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;正文&lt;/h3&gt;

&lt;p&gt;话不多说，赶紧进入正文。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;0 旅行的开始&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg1.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;@尚文慧，@赖剑清，新同学为大家献唱“一眼万年”，看好你们。。。。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg2.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;伴随着歌声，我们来到了美丽的海滨小城 —- 象山！开启了TB之旅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg3.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;放眼望去，这么多负氧离子，都想立马冲下车去拥抱大自然（我能告诉你是因为坐了5个小时大巴的原因吗？）&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;1 第一个景点 —- 渔港古城&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg4.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1公里的历史小城，容纳了太多当地渔民的感情寄托。伴随着导游的解说，过去渔民生活场景浮现眼前。他们勤劳，对大海的敬畏，勇敢抵御外敌。。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg5.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;2 第二景点 —- 象山海滨&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg11.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一张全家福哦！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg14.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一对好姐妹。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg15.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg16.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;画风突变，请坐稳椅子。@风一样的女子。&lt;/p&gt;

&lt;p&gt;海边是一个秀身材的好地方，大家都怎么秀的？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg17.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;健硕的男子，幸福美满的一堆新夫妻！祝你们新婚快乐。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg18.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;@飞哥，霸气的胸肌，把身后所有的游客深深的比下去了！好身材！！！！！！（话说，那块玉好值钱的吧。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg19.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没看够，再来一张。后面的胖子，你抢镜了。。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg20.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;@水民，踏浪而来，你兄弟哪吒在哪里？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg9.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;@建军，一群好基友。大家帮你玩水呢。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg10.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看这表情，是不是在说，“兄弟们，我还要！！！”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg8.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;@土豪，摄影师和你有多大仇？&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;3 第三景点 —- 芝林&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg21.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg22.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;@产品汪，泥垢了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg23.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg24.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;天人合一&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg25.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;水雷大战&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg26.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;兔子，smile D:)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg27.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;竹林里的全家福，绿意满满的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg29.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;溪水中，一秒变猴子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg30.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看不下去水民了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7qn9j4.com1.z0.glb.clouddn.com/tbimg31.jpg&quot; style=&quot;width:100%;border:1px solid #ccc;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;爬到山顶的同学，你们好样的！为你们点赞，多亏你们为我们带回来山顶的风景（让我晚1小时吃饭！）&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;总结&lt;/h4&gt;

&lt;p&gt;快乐的时光总是那么短暂，旅行结束了，但是我们心里的旅行才出发。&lt;/p&gt;

&lt;p&gt;fighting！！！@蔡飞团队。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>git .ssh key install</title>
   <link href="/2015/08/03/git-ssh-key-install/"/>
   <updated>2015-08-03T00:00:00+08:00</updated>
   <id>/2015/08/03/git-ssh-key-install</id>
   <content type="html">
</content>
 </entry>
 
 <entry>
   <title>开始写es6吧</title>
   <link href="/2015/04/28/start-to-write-es6/"/>
   <updated>2015-04-28T00:00:00+08:00</updated>
   <id>/2015/04/28/start-to-write-es6</id>
   <content type="html">
&lt;h1 id=&quot;es6&quot;&gt;开始写es6吧&lt;/h1&gt;

&lt;h2 id=&quot;ecmascript-6&quot;&gt;ECMAScript 6简介&lt;/h2&gt;

&lt;p&gt;ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准，正处在快速开发之中，大部分已经完成了，预计将在2015年6月正式发布。Mozilla公司将在这个标准的基础上，推出JavaScript 2.0。&lt;/p&gt;

&lt;p&gt;ES6的目标，是使得JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。&lt;/p&gt;

&lt;h2 id=&quot;es6-1&quot;&gt;ES6语法&lt;/h2&gt;

&lt;p&gt;传送门 &lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot;&gt;ECMAScript 6入门 作者：阮一峰&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了下文需要简单先说几个ES6的语法特征。&lt;/p&gt;

&lt;p&gt;ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;10;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ReferenceError:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;defined.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;部署环境&lt;/h2&gt;

&lt;p&gt;node从0.11+支持ES6更多的新特征，如果你的node版本低的话，那就去升级吧。window下如何升级，&lt;a href=&quot;http://wikieswan.github.io/node/2015/04/28/reinstall-node-on-window-os/&quot;&gt;点击传送门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面是干货了，亲们注意了：&lt;/p&gt;

&lt;h3 id=&quot;js-use-strict-&quot;&gt;js文件以 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;use strict&quot;;&lt;/code&gt; 开头&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;use strict&quot;;
{
    let a = 1;
    console.log(a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;node-run---harmony-&quot;&gt;node run的时候加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;--harmony&lt;/code&gt; 参数&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ node --harmony demo.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就可以正常运行ES6的代码了，快去尝尝鲜吧。 需要注意的是，部分ES6的特性node 现在是不完全支持的，所以如果出现部分语法编译执行报错，不要慌张，等等呗！&lt;/p&gt;

&lt;h2 id=&quot;iojses6&quot;&gt;iojs运行ES6&lt;/h2&gt;

&lt;p&gt;什么？你觉得run代码的时候，在控制台输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;--harmony&lt;/code&gt; 是一件很挫的事情！ 是的，很多人都这样觉得，所以才有了 &lt;code class=&quot;highlighter-rouge&quot;&gt;iojs&lt;/code&gt; 。那我们再试试这个神器吧！&lt;/p&gt;

&lt;p&gt;首先要下载 &lt;code class=&quot;highlighter-rouge&quot;&gt;iojs&lt;/code&gt; ,&lt;a href=&quot;https://iojs.org/en/index.html&quot;&gt;传送门&lt;/a&gt; 。安装之后就可以在命令行中输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;iojs demo.js&lt;/code&gt; 就可以跑ES5代码了。当然别忘记在js代码头部加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;use strict&quot;;&lt;/code&gt; 。&lt;/p&gt;

&lt;h2 id=&quot;es6-2&quot;&gt;在项目中用ES6&lt;/h2&gt;

&lt;p&gt;上面介绍的两种run ES6的方式是在命令行中，那么我迫不及待要在项目中运用怎么办？&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;babel&lt;/code&gt; 神器助你一臂之力。&lt;/p&gt;

&lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;babel&lt;/code&gt; 有多中方式，&lt;a href=&quot;https://babeljs.io/docs/using-babel/&quot;&gt;using babel&lt;/a&gt; .总有一款属于你。&lt;/p&gt;

&lt;p&gt;下面来看看 gulp编译的 ES6 to ES5的前后过程吧&lt;/p&gt;

&lt;p&gt;项目文件结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;es6demo
    dist
        es6.js
    src
        es6.js
    node_modules
    gulpfile.js
    package.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中package.json关键代码，是对gulp-babel的依赖。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;dependencies&quot;: {
    &quot;gulp&quot;: &quot;^3.8.11&quot;,
    &quot;gulp-babel&quot;: &quot;^5.1.0&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;gulpfile.js 的代码，主要作用是吧src中的es6代码以es5的形式编译到dist中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);
var babel = require(&#39;gulp-babel&#39;);
gulp.task(&#39;default&#39;, [&#39;watch&#39;]);
gulp.task(&#39;watch&#39;, function () {
    gulp.watch([&#39;src/**/*.js&#39;], [&#39;babel&#39;]);
});
gulp.task(&#39;babel&#39;, function () {
    return gulp.src(&#39;src/**/*.js&#39;)
        .pipe(babel())
        .pipe(gulp.dest(&#39;dist&#39;));
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么先睹为快吧&lt;/p&gt;

&lt;p&gt;src 中的 es6.js代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;use strict&quot;;
{
    let a = 1;        
}
console.log(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;dist 中的 es6.js代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;use strict&quot;;
{
    var _a = 1;
}
console.log(a);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过改变变量名称，把es6中的 a 变成 _a ，这样就实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt; 中 &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; 的局部变量的过程。是不是很挫！！！ 不过能用就好啦。
发现更多？自己去试试吧。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>window下卸载并重新安装node</title>
   <link href="/2015/04/28/reinstall-node-on-window-os/"/>
   <updated>2015-04-28T00:00:00+08:00</updated>
   <id>/2015/04/28/reinstall-node-on-window-os</id>
   <content type="html">
&lt;h1 id=&quot;windownode&quot;&gt;window下卸载并重新安装node&lt;/h1&gt;

&lt;h2 id=&quot;node&quot;&gt;卸载node&lt;/h2&gt;

&lt;p&gt;window下安装node是到&lt;a href=&quot;https://nodejs.org/download/&quot;&gt;node官网下载页面&lt;/a&gt;去下载对应系统的msi。它会集成了npm，当然你可以手动下载node.exe，然后手动安装npm。&lt;/p&gt;

&lt;p&gt;卸载node的话，我们也需要用msi文件。如果从控制面板里面卸载node，然后把 program 文件下的node文件和 appData中的 node 文件都手动删除，还是不能完全卸载node的。当下载了一个新的node安装包，会出现下面的报错信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The feature you are trying to use is on a newwork resource that is unavailable.
Click OK to try again,ro entrer an alternate path to a folder cantaining the installation package &#39;node-v0.10.26-x86.msi&#39; in ths box below
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://wikieswan.qiniudn.com/reinstallnode.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时候，你需要到到&lt;a href=&quot;http://nodejs.org/dist/&quot;&gt;官网&lt;/a&gt;上去下载这个版本的 msi 文件。这种情况产生的原因是我们已经移除了当初的安装包。
下载下来报错内容提示的安装包，放到错误信息中的路径去，然后启动安装包，选择卸载这个版本的 node 。这时候，这个版本的 node 就从电脑中彻底移除了 。  可以安装新版本的 node msi程序了。&lt;/p&gt;

&lt;p&gt;总结：window 卸载 node ，必须用对应的安装包 msi。&lt;/p&gt;

&lt;p&gt;祝好运！&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>sass 控制指令用法说明</title>
   <link href="/2015/04/07/sass-control-directives/"/>
   <updated>2015-04-07T00:00:00+08:00</updated>
   <id>/2015/04/07/sass-control-directives</id>
   <content type="html">
&lt;h2 id=&quot;sass---ifforeach--while&quot;&gt;sass 的控制指令 ： @if,@for,@each 和 @while&lt;/h2&gt;

&lt;p&gt;sass控制指令是创建一个可重用、可分布的库的基础。当谈及Sass技术的时候，这也是首当其冲需要掌握的。&lt;/p&gt;

&lt;h2 id=&quot;sass&quot;&gt;这是一堂很有基情的Sass指令课程&lt;/h2&gt;

&lt;p&gt;Sass指令提供文件流和逻辑，用混合函数让你写出有层次的css代码。&lt;/p&gt;

&lt;p&gt;这一课程中我们来学习一下 ： @if, @for, @each 和 @while.&lt;/p&gt;

&lt;h2 id=&quot;if&quot;&gt;@if&lt;/h2&gt;

&lt;p&gt;在SassScript表达式中，当&lt;code class=&quot;highlighter-rouge&quot;&gt;@if&lt;/code&gt; 控制指令返回一个非&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;的值，结果就会执行到 &lt;code class=&quot;highlighter-rouge&quot;&gt;@if&lt;/code&gt; 中的代码样式。&lt;/p&gt;

&lt;p&gt;下面用一个例子说明：&lt;/p&gt;

&lt;p&gt;sass 代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Set a variable to run the if statement against
$boolean: true !default

=simple-mixin
  @if $boolean
    @debug &quot;$boolean is #{$boolean}&quot;
    display: block
  @else
    @debug &quot;$boolean is #{$boolean}&quot;
    display: none

.some-selector
  +simple-mixin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编译后的css代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.some-selector {
  display: block;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意我在每一个流操作之后添加了&lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt;指令。这不是重点，但是要告诉你在命令行中怎么获取变量的值。
你也可以试试 &lt;code class=&quot;highlighter-rouge&quot;&gt;@warn&lt;/code&gt;指令。对于复杂的混合和函数，这样可以提供一个的开发经验，更好的进行调试发现问题。&lt;/p&gt;

&lt;p&gt;例如，如果你在命令行中运行下面的代码，你会看到下面的结果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/Users/.../screen.sass:8 DEBUG: $boolean is true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;for&quot;&gt;@for&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@for&lt;/code&gt;控制指令有两种形式&lt;/p&gt;

&lt;p&gt;第一种 ： &lt;code class=&quot;highlighter-rouge&quot;&gt;@for $var from &amp;lt;start&amp;gt; through &amp;lt;end&amp;gt;&lt;/code&gt; ，从&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;start&amp;gt;&lt;/code&gt;开始，对每个迭代器进行循环，在循环过&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;end&amp;gt;&lt;/code&gt;后结束。
很直接吧。&lt;/p&gt;

&lt;p&gt;第二种 ： &lt;code class=&quot;highlighter-rouge&quot;&gt;@for $var from &amp;lt;start&amp;gt; to &amp;lt;end&amp;gt;&lt;/code&gt; ，从&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;start&amp;gt;&lt;/code&gt;开始，对每个迭代器进行循环，在循环&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;end&amp;gt;&lt;/code&gt;前结束。&lt;/p&gt;

&lt;p&gt;两个区别是&lt;code class=&quot;highlighter-rouge&quot;&gt;through&lt;/code&gt;会循环到最后一个索引，而&lt;code class=&quot;highlighter-rouge&quot;&gt;to&lt;/code&gt;会在到最后一个索引前终止循环。&lt;/p&gt;

&lt;h2 id=&quot;each&quot;&gt;@each&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@each&lt;/code&gt;指令的形式是&lt;code class=&quot;highlighter-rouge&quot;&gt;@each $var in &amp;lt;list&amp;gt;&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;sass代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$list: adam john wynn mason kuroir

=author-images
  @each $author in $list
    .photo-#{$author}
      background: image-url(&quot;avatars/#{$author}.png&quot;) no-repeat

.author-bio
  +author-images
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;css代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.author-bio .photo-adam {
  background: url(&#39;/images/avatars/adam.png&#39;) no-repeat;
}
.author-bio .photo-john {
  background: url(&#39;/images/avatars/john.png&#39;) no-repeat;
}
.author-bio .photo-wynn {
  background: url(&#39;/images/avatars/wynn.png&#39;) no-repeat;
}
.author-bio .photo-mason {
  background: url(&#39;/images/avatars/mason.png&#39;) no-repeat;
}
.author-bio .photo-kuroir {
  background: url(&#39;/images/avatars/kuroir.png&#39;) no-repeat;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;while&quot;&gt;@while&lt;/h2&gt;

&lt;p&gt;sass代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$types: 4
$type-width: 20px

@while $types &amp;gt; 0
  .while-#{$types}
    width: $type-width + $types
  $types: $types - 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;css代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.while-4 {
  width: 24px;
}

.while-3 {
  width: 23px;
}

.while-2 {
  width: 22px;
}

.while-1 {
  width: 21px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://thesassway.com/intermediate/if-for-each-while&quot;&gt;http://thesassway.com/intermediate/if-for-each-while&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>ko with 绑定说明</title>
   <link href="/2015/04/07/ko-with/"/>
   <updated>2015-04-07T00:00:00+08:00</updated>
   <id>/2015/04/07/ko-with</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;作用&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt;绑定创建了一个新的的绑定上下文，这样在被绑定对象的后代元素也就绑定到上下文中了。&lt;/p&gt;

&lt;p&gt;当然你也可以把 &lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt;绑定和其他控制流绑定一起结合使用，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;样例1 静态绑定&lt;/h2&gt;

&lt;p&gt;这里有一个简单例子来说明把绑定的上下文切换到一个孩子对象上。注意：在&lt;code class=&quot;highlighter-rouge&quot;&gt;data-bind&lt;/code&gt;属性中，没有必要给&lt;code class=&quot;highlighter-rouge&quot;&gt;latitude&lt;/code&gt;或者
&lt;code class=&quot;highlighter-rouge&quot;&gt;longitude&lt;/code&gt;加上&lt;code class=&quot;highlighter-rouge&quot;&gt;coords&lt;/code&gt;前缀。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;h1 data-bind=&quot;text: city&quot;&amp;gt; &amp;lt;/h1&amp;gt;
&amp;lt;p data-bind=&quot;with: coords&quot;&amp;gt;
    Latitude: &amp;lt;span data-bind=&quot;text: latitude&quot;&amp;gt; &amp;lt;/span&amp;gt;,
    Longitude: &amp;lt;span data-bind=&quot;text: longitude&quot;&amp;gt; &amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;
 
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    ko.applyBindings({
        city: &quot;London&quot;,
        coords: {
            latitude:  51.5001524,
            longitude: -0.1262362
        }
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;样例2 动态双向绑定&lt;/h2&gt;

&lt;p&gt;这个例子说明：&lt;/p&gt;

&lt;p&gt;1 &lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt;绑定能够动态的添加或者删除绑定对象的后代元素取决于是否把相关的后代值设为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;2 如果你想从父对象绑定上下文中获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;function&lt;/code&gt; ，你可以使用特殊的上下文属性，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;$parent&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;$root&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;view 代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;form data-bind=&quot;submit: getTweets&quot;&amp;gt;
    Twitter account:
    &amp;lt;input data-bind=&quot;value: twitterName&quot; /&amp;gt;
    &amp;lt;button type=&quot;submit&quot;&amp;gt;Get tweets&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
 
&amp;lt;div data-bind=&quot;with: resultData&quot;&amp;gt;
    &amp;lt;h3&amp;gt;Recent tweets fetched at &amp;lt;span data-bind=&quot;text: retrievalDate&quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;/h3&amp;gt;
    &amp;lt;ol data-bind=&quot;foreach: topTweets&quot;&amp;gt;
        &amp;lt;li data-bind=&quot;text: text&quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ol&amp;gt;
 
    &amp;lt;button data-bind=&quot;click: $parent.clearResults&quot;&amp;gt;Clear tweets&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;View model 代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function AppViewModel() {
    var self = this;
    self.twitterName = ko.observable(&#39;@example&#39;);
    self.resultData = ko.observable(); // No initial value
 
    self.getTweets = function() {
        var name = self.twitterName(),
            simulatedResults = [
                { text: name + &#39; What a nice day.&#39; },
                { text: name + &#39; Building some cool apps.&#39; },
                { text: name + &#39; Just saw a famous celebrity eating lard. Yum.&#39; }
            ];
 
        self.resultData({ retrievalDate: new Date(), topTweets: simulatedResults });
    }
 
    self.clearResults = function() {
        self.resultData(undefined);
    }
}
 
ko.applyBindings(new AppViewModel());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参数&lt;/h2&gt;

&lt;p&gt;一个你想用来绑定到上下文中的对象&lt;/p&gt;

&lt;p&gt;如果对象值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;，那么它的后代元素的都不会被绑定，但是也不会被从文档中移除。&lt;/p&gt;

&lt;p&gt;如果这个对象表达式中包含观察者变量，那么无论什么时候这些观察者变量发生变化，这个表达式都会被重新计算值。然后所有的后代元素都会被清除，并且被标记对象一份新的备份值会被添加到文档中，用表达式的新值绑定到上下文中去。&lt;/p&gt;

&lt;h2 id=&quot;with&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt;不带元素的绑定&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;Header element&amp;lt;/li&amp;gt;
    &amp;lt;!-- ko with: outboundFlight --&amp;gt;
        ...
    &amp;lt;!-- /ko --&amp;gt;
    &amp;lt;!-- ko with: inboundFlight --&amp;gt;
        ...
    &amp;lt;!-- /ko --&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考地址:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://knockoutjs.com/documentation/with-binding.html&quot;&gt;http://knockoutjs.com/documentation/with-binding.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>localStorage 介绍</title>
   <link href="/2015/04/03/html5-api-localstorage/"/>
   <updated>2015-04-03T00:00:00+08:00</updated>
   <id>/2015/04/03/html5-api-localstorage</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;localStorage 是html5的新特性，它提供了一个能在浏览器端做数据存储的对象。&lt;/p&gt;

&lt;h2 id=&quot;localstorage-api&quot;&gt;localStorage API&lt;/h2&gt;

&lt;p&gt;1 clear()
清空本地localStorage存储。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
	localStorage.clear()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2 getItem(‘key’)
获取localStorage对象中key为参数的对象值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
	localStorage.getItem(&#39;key&#39;)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3 setItem(‘key’,value)
设置localStorage中键值为key对象的值为value&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
	localStorage.setItem(&#39;key&#39;,value)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4 removeItem(‘key’)
删除localStorage中键值为key的对象&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
	localStorage.removeItem(&#39;key&#39;)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;5 key(index)
获取索引值为index的key值&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
	localStorage.key(0)
&lt;/code&gt;
6 length
	localStorage的长度属性&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
	localStorage.length
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;一段小程序介绍上面接口的用法&lt;/h2&gt;

&lt;p&gt;```javascript
	//清空
	localStorage.clear()&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//查看当前的 localStorage 对象
localStorage
Storage {length: 0}

//新增一个&#39;name&#39;属性，它的值是&#39;lucy&#39;
localStorage.setItem(&#39;name&#39;,&#39;lucy&#39;)

//查看 &#39;name&#39;属性的值
localStorage.getItem(&#39;name&#39;)
&quot;lucy&quot;

//这时候 localStorage 的长度是1
localStorage.length
1

//localStorage 的第一个对象的key是 &#39;name&#39;
localStorage.key(0)
&quot;name&quot;

//删除&#39;name&#39;属性
localStorage.removeItem(&#39;name&#39;)

//这时候localStorage的长度是 0
localStorage
Storage {length: 0} ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;兼容性&lt;/h2&gt;
&lt;p&gt;localStorage 对象是html5的新特性，老版本的浏览器是不兼容的。我们先来看看都有哪些兼容。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;桌面浏览器
Feature		Chrome	Ff	IE	Opera	Safari (WebKit)
localStorage	4	3.5	8	10.50	4
sessionStorage	5	2	8	10.50	4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;更多请查看&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但是，并不是说老版本的浏览器就没有机会尝试这种新家伙了，我们可以用cookie来做老版本浏览器的兼容。&lt;/p&gt;

&lt;p&gt;这段代码是用cookie来模拟 localStorage 对象的特性&lt;/p&gt;

&lt;p&gt;```javascript&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (!window.localStorage) {
  Object.defineProperty(window, &quot;localStorage&quot;, new (function () {
    var aKeys = [], oStorage = {};
    Object.defineProperty(oStorage, &quot;getItem&quot;, {
      value: function (sKey) { return sKey ? this[sKey] : null; },
      writable: false,
      configurable: false,
      enumerable: false
    });
    Object.defineProperty(oStorage, &quot;key&quot;, {
      value: function (nKeyId) { return aKeys[nKeyId]; },
      writable: false,
      configurable: false,
      enumerable: false
    });
    Object.defineProperty(oStorage, &quot;setItem&quot;, {
      value: function (sKey, sValue) {
        if(!sKey) { return; }
        document.cookie = escape(sKey) + &quot;=&quot; + escape(sValue) + &quot;; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/&quot;;
      },
      writable: false,
      configurable: false,
      enumerable: false
    });
    Object.defineProperty(oStorage, &quot;length&quot;, {
      get: function () { return aKeys.length; },
      configurable: false,
      enumerable: false
    });
    Object.defineProperty(oStorage, &quot;removeItem&quot;, {
      value: function (sKey) {
        if(!sKey) { return; }
        document.cookie = escape(sKey) + &quot;=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/&quot;;
      },
      writable: false,
      configurable: false,
      enumerable: false
    });
    this.get = function () {
      var iThisIndx;
      for (var sKey in oStorage) {
        iThisIndx = aKeys.indexOf(sKey);
        if (iThisIndx === -1) { oStorage.setItem(sKey, oStorage[sKey]); }
        else { aKeys.splice(iThisIndx, 1); }
        delete oStorage[sKey];
      }
      for (aKeys; aKeys.length &amp;gt; 0; aKeys.splice(0, 1)) { oStorage.removeItem(aKeys[0]); }
      for (var aCouple, iKey, nIdx = 0, aCouples = document.cookie.split(/\s*;\s*/); nIdx &amp;lt; aCouples.length; nIdx++) {
        aCouple = aCouples[nIdx].split(/\s*=\s*/);
        if (aCouple.length &amp;gt; 1) {
          oStorage[iKey = unescape(aCouple[0])] = unescape(aCouple[1]);
          aKeys.push(iKey);
        }
      }
      return oStorage;
    };
    this.configurable = false;
    this.enumerable = true;
  })());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;我们用cookie来模拟localScorage对象，归根对象的本身还是cookie，那么就会有cookie自身的限制，同一个域下cookie的个数是有限制的，每个cookie对应的长度也是有限制的，一般小于4k。
所以如果用它来存储大数据时，需要考虑到这些限制，以免出现未知错误。&lt;/p&gt;

&lt;p&gt;在对localScorage对象的属性进行增删改查的时候，我们要用 
&lt;code class=&quot;highlighter-rouge&quot;&gt;localStorage.getItem(&#39;key&#39;)&lt;/code&gt; ,&lt;code class=&quot;highlighter-rouge&quot;&gt;localStorage.getItem(&#39;key&#39;,value)&lt;/code&gt; .&lt;code class=&quot;highlighter-rouge&quot;&gt;localStorage.removeItem(&#39;key&#39;)&lt;/code&gt; ;而不是用 &lt;code class=&quot;highlighter-rouge&quot;&gt;localStorage.key&lt;/code&gt; 的方式进行操作。因为这样的话可能不会以正确的方式。&lt;/p&gt;

&lt;p&gt;还有另外一种方式来做 localStorage 对象的兼容性。下面这种方法可以向下兼容到更低版本的IE，比如IE&amp;lt;8的都可以兼容。同样，我们还是用cookie来模拟 localStorage 对象。&lt;/p&gt;

&lt;p&gt;```javascript&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (!window.localStorage) {
  window.localStorage = {
    getItem: function (sKey) {
      if (!sKey || !this.hasOwnProperty(sKey)) { return null; }
      return unescape(document.cookie.replace(new RegExp(&quot;(?:^|.*;\\s*)&quot; + escape(sKey).replace(/[\-\.\+\*]/g, &quot;\\$&amp;amp;&quot;) + &quot;\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*&quot;), &quot;$1&quot;));
    },
    key: function (nKeyId) {
      return unescape(document.cookie.replace(/\s*\=(?:.(?!;))*$/, &quot;&quot;).split(/\s*\=(?:[^;](?!;))*[^;]?;\s*/)[nKeyId]);
    },
    setItem: function (sKey, sValue) {
      if(!sKey) { return; }
      document.cookie = escape(sKey) + &quot;=&quot; + escape(sValue) + &quot;; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/&quot;;
      this.length = document.cookie.match(/\=/g).length;
    },
    length: 0,
    removeItem: function (sKey) {
      if (!sKey || !this.hasOwnProperty(sKey)) { return; }
      document.cookie = escape(sKey) + &quot;=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/&quot;;
      this.length--;
    },
    hasOwnProperty: function (sKey) {
      return (new RegExp(&quot;(?:^|;\\s*)&quot; + escape(sKey).replace(/[\-\.\+\*]/g, &quot;\\$&amp;amp;&quot;) + &quot;\\s*\\=&quot;)).test(document.cookie);
    }
  };
  window.localStorage.length = (document.cookie.match(/\=/g) || window.localStorage).length;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;注意到这两中兼容的写法不同之处在于第一种方式用了 Object.defineProperty() 这个方法。
而这个方法是在IE&amp;gt;=9才支持。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;详细了解请猛戳&lt;/a&gt;.。&lt;/p&gt;

&lt;p&gt;对比这两种兼容方式，官方给的说法是第一种更贴近 localStorage 内部实现的机制，第二种只是在表现形式上进行模拟。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>自己动手做一个前端SPA框架</title>
   <link href="/2015/03/30/front-end-framework-diy/"/>
   <updated>2015-03-30T00:00:00+08:00</updated>
   <id>/2015/03/30/front-end-framework-diy</id>
   <content type="html">
&lt;p&gt;SAP框架当然首选Angular，功能强大，书写简单。但是有的时候我们需要一些实现一些特殊的业务，又不想被框架绑架，比如框架出现了BUG或者特殊需求框架不能满足。那自己动手，来写一个SPA框架。&lt;/p&gt;

&lt;p&gt;业务上，为了解决浏览器兼容问题（兼容到ie8），我们放弃了Angular，选择自建框架。&lt;/p&gt;

&lt;p&gt;材料&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;knockout	//view ui库 
jquery		//js 库 
underscore	//js 库
require		//模块化开发
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;工具&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm	//前端自动化
bower	//包自动化管理器
gulp	//前端开发流程管理
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;项目目录&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://wikieswan.qiniudn.com/spa.jpg&quot; style=&quot;width:100%;border:1px solid #ccc&quot; /&gt;&lt;/p&gt;

&lt;p&gt;框架设计&lt;/p&gt;

&lt;p&gt;index.html作为主页面，在这里引入了必要的样式和库文件。有一个div#body，它来存放每次load到主页面的业务逻辑代码段。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;framework demo&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./resources/somethings.css&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;media=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;screen&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;body&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;载入中...&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./resources/somethings.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./resources/bower_lib/require.mins.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./resources/js/config.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;config.js是框架的js入口文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;requirejs.config({
    baseUrl: &#39;./resources&#39;,
    urlArgs: &#39;1.0.0&#39;,
    paths: {        
        &#39;domReady&#39;:&#39;bower_lib/domReady&#39;,        
        &#39;app&#39;: &#39;app&#39;,
        &#39;mod&#39; : &#39;js/mod&#39;
    }
});
requirejs([&#39;domReady&#39;,&#39;mod/route&#39;,&#39;mod/rootScope&#39;],function(domReady,route,rootScope) {
    domReady(function () {      
        var defaultUrl = rootScope.filePath + &#39;busyness1/index.html&#39;;
        route(defaultUrl);

    });
 });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;route.js模块是整个网站的路由控制器，它的原理是让主页面index.html的div#body按照具体的文件路径加载文件。当业务逻辑文件busyness1/index.html被div#body load之后，busyness1/index.html的代码就会执行，这时候只要在busyness1/index.html页面代码中用script标签引入它对应的逻辑代码busyness1/mod.js代码就可以完成逻辑模块的加载了。具体代码如下：&lt;/p&gt;

&lt;p&gt;route.js 路由控制文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define([],function () {
    return function(url,fn){
        $(&#39;#body&#39;).load(url,function(){
            $(window).scrollTop(0);
            if(typeof fn===&#39;function&#39;){
                fn();
            }
        });
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;rootScope.js 路径配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define([],function () {
    var rootScope = {
        filePath : &#39;./resources/js/app/&#39;,
        domain: &#39;http://www.demo.com&#39;
    };
    return rootScope;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;busyness1/index.html 业务逻辑的html代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div id=&quot;busyness1&quot;&amp;gt;
	&amp;lt;!--view code busyness goes here--&amp;gt;
	&amp;lt;script src=&quot;./resources/js/app/busyness1/mod.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;busyness1/mod.js 业务逻辑的js代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;requirejs([&#39;domReady&#39;],function(domReady) {
    domReady(function () {
    	// js code busyness goes here
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>IE8会下载ajax返回的json</title>
   <link href="/2015/03/11/ie8-contenttype-json-download-a-file/"/>
   <updated>2015-03-11T00:00:00+08:00</updated>
   <id>/2015/03/11/ie8-contenttype-json-download-a-file</id>
   <content type="html">
&lt;p&gt;ie8 不知道对于 application/json 的相应怎么处理 
所以需要在后端处理一下&lt;/p&gt;

&lt;p&gt;比如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static string SetContentTypeBasedOnBrowserAndCommand(HttpContext context)
{
    var contentType = &quot;application/json&quot;; // default
    // if browser is IE
    if (DegreeCore.Util.BrowserUtil.IsIE(context.Request.Browser))
    {
        // override response
         contentType = &quot;text/html&quot;;
    }

    return contentType;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;否则ie8会以文件的形式下载后端的json返回值，文件名以一个随机串结尾。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>不要在循环中使用try catch</title>
   <link href="/2015/02/28/try-catch/"/>
   <updated>2015-02-28T00:00:00+08:00</updated>
   <id>/2015/02/28/try-catch</id>
   <content type="html">
&lt;h2 id=&quot;try-catch&quot;&gt;避免在循环中使用 try-catch&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;try-catch-finally语句在catch语句被执行的过程中会动态构造变量插入到当前域中，对性能有一定影响。&lt;/li&gt;
  &lt;li&gt;如 果需要异常处理机制，可以将其放在循环外层使用。&lt;/li&gt;
  &lt;li&gt;try-catch在正常使用的时候（非循环），是对想能没有影响的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;测试用例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function testTryCatch(loopMax){
	//循环中使用try-catch
	var t1 = (new Date()).getTime();
	try {
	 for (var i = 0; i &amp;lt; loopMax; i++) {}
	} 
	catch (e) {		}
	var t2 = (new Date()).getTime();
	var tmid1 = t2-t1;

	//循环外使用try-catch
	var t3 = (new Date()).getTime();
	for (var i = 0; i &amp;lt; loopMax; i++) {
	 try {} catch (e) {}
	}
	var t4 = (new Date()).getTime();
	var tmid2 = t4-t3;

	console.log(loopMax+&#39; 循环中使用try-catch 耗时&#39; + tmid1);
	console.log(loopMax+&#39; 循环外使用try-catch 耗时&#39; + tmid2);

	console.log(loopMax+&#39; 循环中使用try-catch 单位耗时&#39; + tmid1/loopMax);
	console.log(loopMax+&#39; 循环外使用try-catch 单位耗时&#39; + tmid2/loopMax);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试结果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testTryCatch(100)
100 循环中使用try-catch 耗时0 VM179:22
100 循环外使用try-catch 耗时0 VM179:23
100 循环中使用try-catch 单位耗时0 VM179:25
100 循环外使用try-catch 单位耗时0 VM179:26

testTryCatch(1000)
1000 循环中使用try-catch 耗时0 VM179:22
1000 循环外使用try-catch 耗时0 VM179:23
1000 循环中使用try-catch 单位耗时0 VM179:25
1000 循环外使用try-catch 单位耗时0 VM179:26

testTryCatch(10000)
10000 循环中使用try-catch 耗时0 VM179:22
10000 循环外使用try-catch 耗时1 VM179:23
10000 循环中使用try-catch 单位耗时0 VM179:25
10000 循环外使用try-catch 单位耗时0.0001 VM179:26

testTryCatch(100000)
100000 循环中使用try-catch 耗时0 VM179:22
100000 循环外使用try-catch 耗时1 VM179:23
100000 循环中使用try-catch 单位耗时0 VM179:25
100000 循环外使用try-catch 单位耗时0.00001 VM179:26

testTryCatch(1000000)
1000000 循环中使用try-catch 耗时2 VM179:22
1000000 循环外使用try-catch 耗时4 VM179:23
1000000 循环中使用try-catch 单位耗时0.000002 VM179:25
1000000 循环外使用try-catch 单位耗时0.000004 VM179:26
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结论：在大循环中会出现明显的性能差异。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>SSE 简单入门</title>
   <link href="/2015/02/28/sse-dmeo/"/>
   <updated>2015-02-28T00:00:00+08:00</updated>
   <id>/2015/02/28/sse-dmeo</id>
   <content type="html">
&lt;h2 id=&quot;sse-&quot;&gt;1 SSE 是什么&lt;/h2&gt;

&lt;p&gt;SSE 是 HTML5 的 Server-Sent Events缩写，服务器端发送的事件。网页自动获取服务器端的数据更新。
之前网页获取服务器端更新的数据是需要先想服务器发送情况，确定是否有数据变更，然后获取，而SSE是服务器
一旦有数据更新就主动向网页发送数据。&lt;/p&gt;

&lt;p&gt;浏览器支持&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;API		Chrome 	IE 	Firefox 	Safari 	Opera				
SSE		6.0 	No 	6.0 		5.0 	1.5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;js-eventsource&quot;&gt;2 关键js对象 EventSource&lt;/h2&gt;

&lt;p&gt;EventSource接口用来管理服务器发送事件.你可以通过将EventSource对象的onmessage属性指向一个自定义方法来处理那些从服务器接受到的无类型的消息(也就是,没有event字段的消息).你还可以使用addEventListener()方法来监听其他指定了事件类型的消息.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;3 一个简单的例子&lt;/h2&gt;

&lt;p&gt;我们用一个简单的 SSE demo来介绍SSE的使用，因为我们是前端工程师，所以服务器端我们就用node来实现(ps:其他语言也可以的，只要你愿意)。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;项目文件结构&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SSE
	node_modules
	public
		index.html
	server.js
	package.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;indexhtml&quot;&gt;前端代码 index.html&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!doctype html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;SSE demo&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;pre&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Intializing....&lt;span class=&quot;nt&quot;&gt;&amp;lt;/pre&amp;gt;&lt;/span&gt;

	&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;es&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;EventSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;http://127.0.0.1:8000/sseApi&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;es&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;message&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;#x&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;\n&#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;\n&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;EventSource 的参数就是服务器端提供数据的接口，创建对象es，当有数据向服务器端发送的时候，es的onmessage会触发，在回调函数中
e 指的是服务器发送的对象，我们关心的是里面的数据对象，所以用 e.data接受数据。&lt;/p&gt;

&lt;h3 id=&quot;serverjs&quot;&gt;后端代码  server.js&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require(&#39;express&#39;);
var app = express();
var http = require(&#39;http&#39;);

app.use(express.static(__dirname + &#39;/public&#39;));

app.get(&#39;/sseApi&#39;, function(req, res){
	res.writeHead(200,{&#39;Content-Type&#39;:&#39;text/event-stream&#39;})
	var timer = setInterval(function(){
		var content = &#39;data:&#39; + 
			new Date().toISOString() + &#39;\n\n&#39;;
		var b = res.write(content);
		if(!b){
			console.log(&quot;data queued (content=&quot;+content+&quot;)&quot;);
		}
		else{
			console.log(&quot;Flushed!(content=&quot;+content+&quot;)&quot;);
		}
	},1000);
	
	res.connection.on(&#39;close&#39;,function(){
		res.end();
		clearInterval(timer);
		console.log(&quot;Aborting&quot;);
	})
});

app.listen(8000);
console.log(&#39;server start at 8000&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在计时器函数中，每秒向客户端发送服务器当前时间戳。需要注意的是&lt;code class=&quot;highlighter-rouge&quot;&gt;var b = res.write(content);&lt;/code&gt;之后并没有出现&lt;code class=&quot;highlighter-rouge&quot;&gt;res.end();&lt;/code&gt;，而是在关闭连接的时候才出现。当客户端和服务器建立连接之后，直到客户端主动断开连接，否则一直保持连接。
关闭连接的方式是用户离开当前页面，比如关闭页面、跳转到其他页面等。&lt;/p&gt;

&lt;p&gt;注意1&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var content = &#39;data:&#39; + new Date().toISOString() + &#39;\n\n&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以&lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;\n\n&#39;&lt;/code&gt;结尾是SSE协议方式。&lt;/p&gt;

&lt;p&gt;注意2&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.writeHead(200,{&#39;Content-Type&#39;:&#39;text/event-stream&#39;})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发送事件的服务器脚本必须以 &lt;code class=&quot;highlighter-rouge&quot;&gt;text/event-stream&lt;/code&gt;作为相应头.每一条消息都以一对换行符作为结尾.&lt;/p&gt;

&lt;p&gt;参考 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Server-sent_events/Using_server-sent_events&quot;&gt;MDN&lt;/a&gt;:
Sending events from the server
The server-side script that sends events needs to respond using the MIME type text/event-stream. Each notification is sent as a block of text terminated by a pair of newlines. For details on the format of the event stream, see Event stream format.&lt;/p&gt;

&lt;h3 id=&quot;packagejson&quot;&gt;项目配置代码 package.json&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;SSE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1.0.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;main&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;index.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;author&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;license&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ISC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;devDependencies&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;express&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^4.12.0&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当代码完成之后，在浏览器值输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://127.0.0.1:8000/index.html&lt;/code&gt; ，就可以发现页面的数据1s变化一次,用F12查看浏览器控制台,
可以发现有一个接口 sseApi 一直在和服务器保持连接.&lt;/p&gt;

&lt;p&gt;gituhub:&lt;a href=&quot;https://github.com/wikieswan/sse-dmeo&quot;&gt;https://github.com/wikieswan/sse-dmeo&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>获取全局对象 this || (0, eval)('this')</title>
   <link href="/2015/02/27/global-object/"/>
   <updated>2015-02-27T00:00:00+08:00</updated>
   <id>/2015/02/27/global-object</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;获取全局对象&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var window = this || (0, eval)(&#39;this&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;全局变量的正确获取方式如上，那么为什么不能直接用 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 呢？&lt;/p&gt;

&lt;p&gt;在一些封装的js库中，我们经常可以见到上面的写法来获取全局对象，这样的写法很安全，可以保证无论如何方式
引用库文件，都可以把对象追加到全局全局对象下面。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;
表达中的指向的当前调用者，如果在浏览器中，它就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; ，其他环境中就是别的全局对象，比如node的v8环境。所以不能直接用 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 来
表示全局变量。
&lt;code class=&quot;highlighter-rouge&quot;&gt;eval&lt;/code&gt;
的间接调用可以保证当
&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;
无效的时候还可以取到全局对象。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(0, eval)(&#39;this&#39;)&lt;/code&gt; 间接的调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;eval&lt;/code&gt; 。首先解释怎么间接调用，这里用到我们不常用的逗号表达式 &lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;
它的用法可以MDN查下，简单的说一个特征就是逗号表达式是取最后面的一个值作为结果。如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(1,2,3,4,5,6,7,8)
8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;又如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function a(){}
(1,a)
function a(){}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;又如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(0, eval)
function eval() { [native code] }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以&lt;code class=&quot;highlighter-rouge&quot;&gt;(0, eval)(&#39;this&#39;)&lt;/code&gt;的结果是 &lt;code class=&quot;highlighter-rouge&quot;&gt;eval(&#39;this&#39;)&lt;/code&gt; ，这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 指向的调用者。在浏览器中指向的window。&lt;/p&gt;

&lt;p&gt;其次，为什么需要间接调用呢？&lt;code class=&quot;highlighter-rouge&quot;&gt;var window = this || eval(&#39;this&#39;)&lt;/code&gt; 这样写有什么问题？&lt;/p&gt;

&lt;p&gt;看个例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f () {
    console.log(this, eval(&#39;this&#39;), (0, eval)(&#39;this&#39;));
}

var o = {};
f.apply(o);
Object {} Object {} Window {top: Window, window: Window, location: Location, external: Object, chrome: Object…} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个例子中可以看到，无论如何方式调用&lt;code class=&quot;highlighter-rouge&quot;&gt;(0, eval)(&#39;this&#39;)&lt;/code&gt;，返回的都是全局对象，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;eval(&#39;this&#39;)&lt;/code&gt; 可能返回的调用者的对象。
至于为什么会有这样的区别，可以看下面解释。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;eval(&#39;this&#39;)&lt;/code&gt; 获取的对象  &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 所以返回的是空对象；&lt;code class=&quot;highlighter-rouge&quot;&gt;(0, eval)(&#39;this&#39;)&lt;/code&gt;表达式是先接受对象 &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; ，但是执行过程是逗号表达式返回了一个函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;eval()&lt;/code&gt; ，返回的函数再执行的时候，这是的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;则不是指向 &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt; ，
 而是指向了全局对象。所以可以这样延展 &lt;code class=&quot;highlighter-rouge&quot;&gt;(0||eval)()&lt;/code&gt; ，也是可以起到相同的作用。&lt;/p&gt;

&lt;p&gt;参考资料:
 &lt;a href=&quot;http://stackoverflow.com/questions/14119988/return-this-0-evalthis/14120023#14120023&quot;&gt;return this || (0,eval)(‘this’);&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>node http.get 接受数据的方式</title>
   <link href="/2015/02/13/node-httpget-data/"/>
   <updated>2015-02-13T00:00:00+08:00</updated>
   <id>/2015/02/13/node-httpget-data</id>
   <content type="html">
&lt;h2 id=&quot;node--httpget-&quot;&gt;node 中 http.get() 接受数据的正确方式&lt;/h2&gt;

&lt;p&gt;代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get(&#39;/&#39;, function(req, res){
	
	http.get(&quot;http://127.0.0.1:9000/goodsList&quot;, function(res0,data) {
		res0.setEncoding(&#39;utf8&#39;);
		var body = &#39;&#39;;
		res0.on(&#39;data&#39;, function (chunk) {
			body += chunk;
		});
		res0.on(&#39;end&#39;, function() {
			// do with body data
			body = JSON.parse(body)
			
		    //option.goodsList = body.list;
		    //res.render(&#39;index&#39;, option);
		});
	}).on(&#39;error&#39;, function(e) {
	  console.log(&quot;error&quot; + e.message);
	});
	
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，在 ‘end’ 的回调函数中处理数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res0.on(&#39;end&#39;, function() {
	//do with data
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样可以保证接受到完整的数据流之后执行函数。&lt;/p&gt;

&lt;p&gt;如果是在 ‘data’ 事件上绑定对数据的处理的话，如果数据过大，可能在没有接受完整的数据前就开始执行回调函数了，这样就得到错误的结果了。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>node中设置环境是生产或者开发或者测试 node environment setting</title>
   <link href="/2015/02/13/node-environment-setting/"/>
   <updated>2015-02-13T00:00:00+08:00</updated>
   <id>/2015/02/13/node-environment-setting</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;问题场景&lt;/h2&gt;
&lt;p&gt;在不同的环境下，程序调用的接口地址是不一样的。&lt;/p&gt;

&lt;p&gt;在开发 测试 生产的环境中，程序的调用接口地址一般是不一样的。
在stackoverflow上找到一些答案&lt;/p&gt;

&lt;p&gt;Before running your app, you can do this in console,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export NODE_ENV=production
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Or if you are in windows you could try this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SET NODE_ENV=production
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;or you can run your app like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NODE_ENV=production node app.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can also set it in your js file (express/lib/application.js):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;process.env.NODE_ENV = &#39;production&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>nginx windows下命令</title>
   <link href="/2015/02/13/nginx-cmd/"/>
   <updated>2015-02-13T00:00:00+08:00</updated>
   <id>/2015/02/13/nginx-cmd</id>
   <content type="html">
&lt;p&gt;Windows下Nginx的启动、停止等命令
在Windows下使用Nginx，我们需要掌握一些基本的操作命令，比如：启动、停止Nginx服务，重新载入Nginx等，下面我就进行一些简单的介绍。
1、启动：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\server\nginx-1.0.2&amp;gt;start nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\server\nginx-1.0.2&amp;gt;nginx.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：建议使用第一种，第二种会使你的cmd窗口一直处于执行中，不能进行其他命令操作。
2、停止：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\server\nginx-1.0.2&amp;gt;nginx.exe -s stop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\server\nginx-1.0.2&amp;gt;nginx.exe -s quit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。
3、重新载入Nginx：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\server\nginx-1.0.2&amp;gt;nginx.exe -s reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当配置信息修改，需要重新载入这些配置时使用此命令。
4、重新打开日志文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\server\nginx-1.0.2&amp;gt;nginx.exe -s reopen
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5、查看Nginx版本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\server\nginx-1.0.2&amp;gt;nginx -v
nginx: nginx version: nginx/1.0.2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\server\nginx-1.0.2&amp;gt;nginx -V
nginx: nginx version: nginx/1.0.2 
nginx: TLS SNI support enabled 
nginx: configure arguments: --builddir=objs.msvc8 --crossbuild=win32 --with-debug --prefix= --conf-path=conf/nginx.conf --pid-path=logs/nginx.pid --http-log-path=logs/access.log --error-log-path=logs/error.log --sbin-path=nginx.exe --http-client-body-temp-path=temp/client_body_temp --http-proxy-temp-path=temp/proxy_temp --http-fastcgi-temp-path=temp/fastcgi_temp --with-cc-opt=-DFD_SETSIZE=1024 --with-pcre=objs.msvc8/lib/pcre-7.9 --with-zlib=objs.msvc8/lib/zlib-1.2.3 --with-select_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_stub_status_module --with-http_flv_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-mail --with-ipv6 --with-openssl=objs.msvc8/lib/openssl-0.9.8r --with-openssl-opt=enable-tlsext --with-http_ssl_module --with-mail_ssl_module
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：v只是简单显示版本信息，V不但显示版本信息，还显示配置参数信息。
6、测试或载入指定配置文件：
测试配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\server\nginx-1.0.2&amp;gt;nginx.exe -t -c conf/default.conf
nginx: the configuration file C:\server\nginx-1.0.2/conf/default.conf syntax isok
nginx: configuration file C:\server\nginx-1.0.2/conf/default.conf test is successful
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;载入指定配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\server\nginx-1.0.2&amp;gt;start nginx.exe -c conf/default.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>knockoutjs api</title>
   <link href="/2015/02/10/knockoutjs-api/"/>
   <updated>2015-02-10T00:00:00+08:00</updated>
   <id>/2015/02/10/knockoutjs-api</id>
   <content type="html">
&lt;h1 id=&quot;section&quot;&gt;从这里开始&lt;/h1&gt;

&lt;h2 id=&quot;ko&quot;&gt;1.KO怎样工作并且它能给我们带来什么好处？&lt;/h2&gt;

&lt;p&gt;介绍
Knockout是一个以干净的数据模型（data model）为基础的能够帮助你创建富文本，响应显示和编辑用户界面的JavaScript类库。任何时候你的UI部分需要动态更新（比如：更新取决于用户的操作或外部数据源变化）。KO可以帮助你实现由于它更简单并且很容易维护。&lt;/p&gt;

&lt;p&gt;重要特性&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;优雅的依赖跟踪-无论何时你的数据模型改变你的需要变化的UI部分都会自动更新。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;声明式绑定-通过一种简单易懂的方式连接你的数据模型到你的UI部分。你可以非常容易的运用任意的嵌套绑定上下文的方式来构建一个复杂的动态界面。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;傻瓜式扩展-仅仅短短几行代码就可以做出可重用的新声明式绑定来实现用户自定义行为&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;额外的好处&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;纯净的javascript库：兼容所有的服务器端和客户端技术。&lt;/li&gt;
  &lt;li&gt;可以轻松添加到已有的web程序顶部：而不需要大的架构改变。&lt;/li&gt;
  &lt;li&gt;简洁的：压缩后只有13kb&lt;/li&gt;
  &lt;li&gt;兼容任何主流浏览器 (IE 6+、Firefox 2+、Chrome、Safari、其它)。&lt;/li&gt;
  &lt;li&gt;统一的规范(采用行为驱动开发) 意味着在新的浏览器和平台上可以正确的运行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开发者如果熟悉Ruby on Rails (是一个可以使你开发，部署，维护 web 应用程序变得简单的框架。)或其它MVC技术可能会发现它是一个带有声明式语法的MVC实时form。从另一个意义上讲,你能想到可以把KO作为一种编辑JSON数据的方法而不用在乎它怎么工作。&lt;/p&gt;

&lt;p&gt;OK，但是我们怎么使用它呢？
开始的最快和最有趣的方式是通过互动教程。一旦你掌握了基本知识,探索&lt;a href=&quot;###&quot;&gt;live example&lt;/a&gt;,然后在一个自己的项目中运用它了。&lt;/p&gt;

&lt;p&gt;KO和jquery是对立关系，还是相互协作呢？&lt;/p&gt;

&lt;p&gt;所有人都喜欢jQuery! 它是一个在页面里操作元素和事件的框架，非常出色并且易使用，在DOM操作上肯定使用jQuery，KO解决不同的问题。&lt;/p&gt;

&lt;p&gt;如果页面要求复杂，仅仅使用jQuery需要花费更多的代码。 例如：一个表格里显示一个列表，然后统计列表的数量，Add按钮在数据行TR小于5调的时候启用，否则就禁用。jQuery 没有基本的数据模型的概念，所以需要获取数据的数量（从table/div或者专门定义的CSS class），如果需要在某些SPAN里显示数据的数量，当添加新数据的时候，你还要记得更新这个SPAN的text。当然，你还要判断当总数&amp;gt;=5条的时候禁用Add按钮。 然后，如果还要实现Delete功能的时候，你不得不指出哪一个DOM元素被点击以后需要改变。&lt;/p&gt;

&lt;p&gt;Knockout的实现有何不同？&lt;/p&gt;

&lt;p&gt;使用KO非常简单。将你的数据描绘成一个JavaScript数组对象myItems，然后使用模板（template）转化这个数组到表格里（或者一组DIV）。不管什么时候数组改变， UI界面也会响应改变（不用指出如何插入新行&amp;lt;tr&amp;gt;或在哪里插入），剩余的工作就是同步了。例如：你可以声明绑定如下一个SPAN显示数据数量（可以放在页面的任何地方，不一定非要在template里）：&lt;/p&gt;

&lt;p&gt;There are &lt;span data-bind=&quot;text: myItems().count&quot;&gt;&lt;/span&gt; items
  就是这些！你不需要写代码去更新它，它的更新依赖于数组myItems的改变。同样， Add按钮的启用和禁用依赖于数组myItems的长度，如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
  &amp;lt;button data-bind=&quot;enable: myItems().count &amp;lt; 5&quot;&amp;gt;Add&amp;lt;/button&amp;gt;
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;之后，如果你要实现Delete功能，不必指出如何操作UI元素，只需要修改数据模型就可以了。&lt;/p&gt;

&lt;p&gt;总结：KO没有和jQuery或类似的DOM 操作API对抗竞争。KO提供了一个关联数据模型和用户界面的高级功能。KO本身不依赖jQuery，但是你可以一起同时使用jQuery， 生动平缓的UI改变需要真正使用jQuery。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.下载和安装&lt;/h2&gt;

&lt;h1 id=&quot;section-2&quot;&gt;监控属性&lt;/h1&gt;

&lt;h2 id=&quot;section-3&quot;&gt;1.创建可见的监控模型&lt;/h2&gt;

&lt;p&gt;Knockout是在以下三个功能上建立起来的：&lt;/p&gt;

&lt;p&gt;1.监控属性和依赖跟踪&lt;/p&gt;

&lt;p&gt;2.声明式绑定&lt;/p&gt;

&lt;p&gt;3.模板&lt;/p&gt;

&lt;p&gt;这一节，你讲学到3个功能中的第一个。 在这之前， 我们先来解释一下MVVM模式和view model的概念。&lt;/p&gt;

&lt;p&gt;MVVM and View Models&lt;/p&gt;

&lt;p&gt;Model-View-View Model (MVVM) 是一种构建用户界面的设计模式。它描述了如果把一个复杂的UI分成三部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A model： 你的应用程序存储的数据。这个数据表示对象和业务领域的操作(比如银行业务-可以执行转账)，并且它独立于任何UI。当你使用KO的时候，model通常指的是利用ajax从服务器端读取和写入进去的数据模型。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A view model: 一些纯粹的代码表示UI层面的数据和操作。例如，你正在实现列表编辑，你的视图模型就是列表项目对象和增删改查操作方法。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意这不是UI本身：它不包含任何按钮的概念或者显示风格。它也不是持续数据模型 – 包含用户正在使用的未保存数据。使用KO的时候，你的view models是不包含任何HTML知识的纯JavaScript 对象。保持view model抽象可以保持简单，以便你能管理更复杂的行为。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;view: 一个可见的，交互式的，表示view model状态的UI。 从view model显示数据，发送命令到view model（例如：当用户click按钮的时候） ，任何view model状态改变的时候更新。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;binding&quot;&gt;绑定 binding&lt;/h1&gt;

&lt;h2 id=&quot;section-4&quot;&gt;文本和展现的控制&lt;/h2&gt;

&lt;h3 id=&quot;visible-&quot;&gt;1 visible 绑定&lt;/h3&gt;
&lt;!-- text绑定 --&gt;

&lt;p&gt;作用&lt;/p&gt;

&lt;p&gt;visible 根据变量值的true或者false来控制DOM元素的显示或者隐藏。&lt;/p&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;iframe width=&quot;480&quot; height=&quot;360&quot; src=&quot;http://codepen.io/anon/embed/LEREKG?slug-hash=LEREKG&amp;amp;default-tab=result&amp;amp;height=300&amp;amp;theme-id=0&amp;amp;user=anon&quot; frameborder=&quot;0&quot;&gt; &lt;/iframe&gt;

&lt;p&gt;参数说明&lt;/p&gt;

&lt;p&gt;主要参数&lt;/p&gt;

&lt;p&gt;参数值为类似false值（eg，false、0、null、undefined）把yourElement.style.display设置为none，元素就隐藏了。&lt;/p&gt;

&lt;p&gt;参数值为类似true值（eg，true、非null 的对象），则元素会显示。&lt;/p&gt;

&lt;p&gt;如果参数是一个observable 变量，无论参数的值什么时候发生变化，元素的visible属性也会发生改变的。如果参数不是一个observable 变量，那么只会在第一次绑定的时候控制元素的visible属性，之后元素的visible属性不会发生变化。&lt;/p&gt;

&lt;p&gt;其他参数&lt;/p&gt;

&lt;p&gt;无&lt;/p&gt;

&lt;p&gt;注意 使用函数或者表达式控制元素的显示或者隐藏&lt;/p&gt;

&lt;p&gt;可以是用javascript函数或者表达式作为参数；knockout会运行函数或者表达式，用返回值来作为参数，从而觉得元素的显示或者隐藏。&lt;/p&gt;

&lt;p&gt;e.g.&lt;/p&gt;

&lt;iframe width=&quot;480&quot; height=&quot;360&quot; src=&quot;http://codepen.io/anon/embed/wBzaXR?slug-hash=wBzaXR&amp;amp;default-tab=result&amp;amp;height=300&amp;amp;theme-id=0&amp;amp;user=anon &quot; frameborder=&quot;0&quot;&gt; &lt;/iframe&gt;

&lt;p&gt;依赖&lt;/p&gt;

&lt;p&gt;无&lt;/p&gt;

&lt;!-- text绑定 --&gt;

&lt;h3 id=&quot;text-&quot;&gt;2 text 绑定&lt;/h3&gt;

&lt;p&gt;作用&lt;/p&gt;

&lt;p&gt;text 绑定让DOM元素显示参数的值。对于 span 、 em 这些常用来表示文本的标签起作用，但是你想绑定在其他标签上也是可以的。&lt;/p&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;iframe width=&quot;480&quot; height=&quot;360&quot; src=&quot;http://codepen.io/anon/embed/ZYpYgZ?slug-hash=ZYpYgZ&amp;amp;default-tab=result&amp;amp;height=300&amp;amp;theme-id=0&amp;amp;user=anon &quot; frameborder=&quot;0&quot;&gt; &lt;/iframe&gt;

&lt;p&gt;参数说明&lt;/p&gt;

&lt;p&gt;主要参数&lt;/p&gt;

&lt;p&gt;Knockout 用参数的值设置DOM元素的text属性值；DOM元素原先的值会被复写。&lt;/p&gt;

&lt;p&gt;如果参数是一个observable变量，那么一旦参数的值发生变化，页面上绑定的值都会立即改变；如果不是，那么只会在第一次绑定的时候改变页面元素的文本值，页面上的值之后就不会再被改变。&lt;/p&gt;

&lt;p&gt;如果参数的类型不是number或者string（e.g., 对象或者数组），那么页面上展示的文本是对象到字符串等效转化的值，相当于yourParameter.toString()&lt;/p&gt;

&lt;p&gt;其他参数&lt;/p&gt;

&lt;p&gt;无&lt;/p&gt;

&lt;p&gt;注意1：使用函数和表达式获取文本的值&lt;/p&gt;

&lt;p&gt;如果想通过程序方式确定文本的值，那么需要用到可计算的observable,用可以返回文本的函数名作为参数。&lt;/p&gt;

&lt;p&gt;e.g.&lt;/p&gt;

&lt;iframe width=&quot;480&quot; height=&quot;360&quot; src=&quot;http://codepen.io/anon/embed/bNwdLO?slug-hash=bNwdLO&amp;amp;default-tab=result&amp;amp;height=300&amp;amp;theme-id=0&amp;amp;user=anon&quot; frameborder=&quot;0&quot;&gt; &lt;/iframe&gt;

&lt;p&gt;那么文本的值就会根据price 的&lt;/p&gt;

&lt;p&gt;变化而取 “expensive” 或者 “affordable” 。&lt;/p&gt;

&lt;p&gt;另外，如果像下面那样只做简单的逻辑处理的话，是不需要创建可计算的observable的函数的。你可以传递任何的javascript表达式作为数据绑定。e.g.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
The item is &amp;lt;span data-bind=&quot;text: price() &amp;gt; 50 ? &#39;expensive&#39; : &#39;affordable&#39;&quot;&amp;gt;&amp;lt;/span&amp;gt; today.
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意2 HTML编码&lt;/p&gt;

&lt;p&gt;既然绑定是用文本节点的值来设置页面上文本的值的，那么为了安全起见，设置任何字符串值的时候都应该避免HTML或者script注入。&lt;/p&gt;

&lt;p&gt;e.g.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
viewModel.myMessage(&quot;&amp;lt;i&amp;gt;Hello, world!&amp;lt;/i&amp;gt;&quot;);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这段代码不会在页面上渲染出斜体文本，（即html标签不会被浏览器解析渲染），而是在页面上直接原样显示。&lt;/p&gt;

&lt;p&gt;如果你要在数据模型中设置html代码，请看下文关于html绑定的说明。&lt;/p&gt;

&lt;p&gt;注意3 不适用html元素完成文本绑定&lt;/p&gt;

&lt;p&gt;有时候，你想完成数据绑定而不引入额外的HTML元素。例如，在option标签中引入额外的元素是不可以的，像下面的代码是不会生效的：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
&amp;lt;select data-bind=&quot;foreach: items&quot;&amp;gt;
  &amp;lt;option&amp;gt;Item &amp;lt;span data-bind=&quot;text: name&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了处理这种情况，需要引入无容器的语法 – 文本注释标签&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
&amp;lt;select data-bind=&quot;foreach: items&quot;&amp;gt;
	&amp;lt;option&amp;gt;Item &amp;lt;!--ko text: name--&amp;gt;&amp;lt;!--/ko--&amp;gt;&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The
&lt;code class=&quot;highlighter-rouge&quot;&gt;
&amp;lt;!--ko--&amp;gt;
&lt;/code&gt;
和
&lt;code class=&quot;highlighter-rouge&quot;&gt;
&amp;lt;!--/ko--&amp;gt; 
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;表示注释区域的开始和结束。用这种方式定义了“虚拟元素”，里面包含了标记绑定。Knockout 会理解这种虚拟元素语法，并且会完成数据绑定。&lt;/p&gt;

&lt;p&gt;注意4 IE 6下怪异的空格&lt;/p&gt;

&lt;p&gt;IE 6会忽略紧跟在span标签后面的空格。例如&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
Welcome, &amp;lt;span data-bind=&quot;text: userName&quot;&amp;gt;&amp;lt;/span&amp;gt; to our web site.
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在IE 6下 to our web site前面的空格不会显示出来，解决这个问题的办法是在span标签里面加上 例如&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
Welcome, &amp;lt;span data-bind=&quot;text: userName&quot;&amp;gt;&amp;amp;nbsp;&amp;lt;/span&amp;gt; to our web site.
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;z在新版本的IE浏览器或者其他浏览器没有这个问题。&lt;/p&gt;

&lt;p&gt;依赖&lt;/p&gt;

&lt;p&gt;只依赖Knockout 核心库&lt;/p&gt;

&lt;!-- html 绑定 --&gt;

&lt;h3 id=&quot;html-&quot;&gt;3 html 绑定&lt;/h3&gt;

&lt;p&gt;html绑定让相关的DOM元素按照参数的内容展示html内容&lt;/p&gt;

&lt;p&gt;尤其是当数据模型中的值是一段你需要展示的html字符的时候，html绑定是你的最爱。&lt;/p&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;iframe width=&quot;480&quot; height=&quot;360&quot; src=&quot;http://codepen.io/anon/embed/RNGPBM?slug-hash=RNGPBM&amp;amp;default-tab=result&amp;amp;height=300&amp;amp;theme-id=0&amp;amp;user=anon &quot; frameborder=&quot;0&quot;&gt; &lt;/iframe&gt;

&lt;p&gt;参数说明&lt;/p&gt;

&lt;p&gt;主要参数&lt;/p&gt;

&lt;p&gt;knockout会先清除绑定元素中的html内容，然后根据情况把参数中的值设置为绑定元素的内容。&lt;/p&gt;

&lt;p&gt;这里的情况分为两种，如果页面中引入了&lt;b&gt;jquery&lt;/b&gt;，那么ko会调用$.html()函数来设置值；如果没有，那么knockout会拷贝参数内容到绑定元素中，然后append到绑定元素上，作为绑定元素的子元素。&lt;/p&gt;

&lt;p&gt;如果参数是一个observable变量，那么无论时候变量发生变化，页面上的值也会随着变量一起变化；否则，只会在首次绑定的改变绑定元素的值，之后不会页面上的值不会随着参数变量值发生变化而变化。&lt;/p&gt;

&lt;p&gt;如果参数的类型不是number或者string（e.g., 对象或者数组），那么页面上展示的文本是对象到字符串等效转化的值，相当于yourParameter.toString()&lt;/p&gt;

&lt;p&gt;其他参数&lt;/p&gt;

&lt;p&gt;无&lt;/p&gt;

&lt;p&gt;注意 HTML 编码&lt;/p&gt;

&lt;p&gt;既然HTML绑定是用&lt;b&gt;innerHTML&lt;/b&gt;来实现的，那么再使用的时候要小心，别引入不被信任的代码片段，因为这可能导致script 注入攻击。如果你不能确认引用的模块是否安全，可以使用text绑定，而它的原理使用&lt;b&gt;innerText &lt;/b&gt;或者&lt;b&gt;textContent &lt;/b&gt;来实现内容绑定的。&lt;/p&gt;

&lt;p&gt;依赖&lt;/p&gt;

&lt;p&gt;只依赖Knockout 核心库&lt;/p&gt;

&lt;!-- css 绑定 --&gt;

&lt;h3 id=&quot;css-&quot;&gt;4 css 绑定&lt;/h3&gt;

&lt;p&gt;作用&lt;/p&gt;

&lt;p&gt;css 可以实现给指定DOM元素增加或者移除一个或者多个class。例如当参数值发生变化的时候，根据需要，给页面元素高亮成红色。&lt;/p&gt;

&lt;p&gt;示例1 静态class&lt;/p&gt;

&lt;iframe width=&quot;480&quot; height=&quot;360&quot; src=&quot;http://codepen.io/anon/embed/pvEJBv?slug-hash=pvEJBv&amp;amp;default-tab=result&amp;amp;height=300&amp;amp;theme-id=0&amp;amp;user=anon &quot; frameborder=&quot;0&quot;&gt; &lt;/iframe&gt;
&lt;p&gt;当currentProfit 的值小于0的时候，元素会加上profitWarning 这个class&lt;/p&gt;

&lt;p&gt;示例2 动态class&lt;/p&gt;

&lt;iframe width=&quot;480&quot; height=&quot;360&quot; src=&quot;http://codepen.io/anon/embed/JoRdVJ?slug-hash=JoRdVJ&amp;amp;default-tab=result&amp;amp;height=300&amp;amp;theme-id=0&amp;amp;user=anon&quot; frameborder=&quot;0&quot;&gt; &lt;/iframe&gt;

&lt;p&gt;当currentProfit是正值的时候，元素会绑定profitPositive  class，否则绑定profitWarning class&lt;/p&gt;

&lt;p&gt;参数说明&lt;/p&gt;

&lt;p&gt;主要参数&lt;/p&gt;

&lt;p&gt;如果你使用静态的CSS class，然后传递一个属性名是CSS类名的javascript对象，根据是否加上CSS类的需求，把它们的值设置为true或者false。&lt;/p&gt;

&lt;p&gt;可以一次设置多个CSS 类。例如，如果数据模型中有一个属性&lt;b&gt;isSevere&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;div data-bind=&quot;css: { profitWarning: currentProfit() &amp;lt; 0, majorHighlight: isSevere }&quot;&gt;
```

用引号括起来多个CSS类，可以实现根据同一个条件来设置多个CSS 类。例如


```
&lt;div data-bind=&quot;css: { profitWarning: currentProfit() &amp;lt; 0, &#39;major highlight&#39;: isSevere }&quot;&gt;
```


非boolean 会被转化为boolean 型。例如0和null被转化为false；数字21或者非空对象被转化为true。

如果参数是一个observable 参数，当参数值发生改变的时候，绑定元素会添加或者移除CSS类。如果不是，那么直会在第一次绑定的时候添加或者移除CSS类，之后不会改变。

如果你想用动态的CSS类，（所谓动态是指参数去不同的值，元素会绑定不同的CSS类），你需要传递一个字符串，这个字符串用来表示将要添加到DOM上的CSS类名。

如果参数是一个observable参数，绑定的时候会移除DOM原先的所有CSS类，然后根据参数的值给元素添加新的CSS类。

通常，可以使用任意的javascript函数或者表达式作为参数。knockout会计算结果，然后根据逻辑决定添加或者移除CSS类。


其他参数

无

注意 不能使用不合法的javascript变量名作为CSS类名

如果你想使用&lt;b&gt;my-class&lt;/b&gt;类名，你不能像下面这样写：

```
&lt;div data-bind=&quot;css: { my-class: someValue }&quot;&gt;&lt;/div&gt;
```

因为这时&lt;b&gt;my-class&lt;/b&gt;不是合法的标示符。解决方案很简单，用引号括起来就可以了。这样CSS类名变成了一个简单的字符串文本，对于javascript对象来说这就是合法的属性名了。换句话说，javascript语言本身不支持带&#39;-&#39;的属性名。
例如

```
	&lt;div data-bind=&quot;css: { &#39;my-class&#39;: someValue }&quot;&gt;&lt;/div&gt;
```

依赖
只依赖Knockout 核心库


&lt;!-- style 绑定 --&gt;

###5 style 绑定

waiting ...



&lt;!-- attr 绑定 --&gt;

###6 attr 绑定

attr提供一个通用的方法来给

示例




  
&lt;iframe width=&quot;480&quot; height=&quot;360&quot; src=&quot;http://codepen.io/anon/embed/qEaONx?slug-hash=qEaONx&amp;amp;default-tab=result&amp;amp;height=300&amp;amp;theme-id=0&amp;amp;user=anon&quot; frameborder=&quot;0&quot;&gt; &lt;/iframe&gt;

参数说明
主要参数



其他参数
无
注意 HTML 编码

依赖
只依赖Knockout 核心库

&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>javascript 原型</title>
   <link href="/2015/02/09/javascript-prototype/"/>
   <updated>2015-02-09T00:00:00+08:00</updated>
   <id>/2015/02/09/javascript-prototype</id>
   <content type="html">
&lt;h2 id=&quot;prototype&quot;&gt;什么是原型 prototype&lt;/h2&gt;
&lt;p&gt;原型是构造器函数的属性。在函数被定义时，会创建一个prototype属性，它的起始值是一个空对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(a,b){
	return a+b;
}

foo.length
&amp;gt;2

foo.constructor
&amp;gt;function Function() { [native code] }

foo.prototype
&amp;gt;foo {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;利用原型添加方法和属性&lt;/h2&gt;
&lt;p&gt;我们现在有一个构造器函数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(name){
	this.name = name;
	this.getName = function(){
		console.log(&#39;my name is &#39; + this.name) ;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以用prototype来添加更多的属性和方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Person.prototype.color = &#39;white&#39;;
Person.prototype.say = function(words){
	console.log(words);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果不想逐一用prototype添加属性和方法，可以利用一个对象，然后覆盖到原来的原型上去。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Person.prototype = {
	color : &#39;white&#39;,
	say : function(words){
		console.log(&#39;i say : &#39;+words)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用原型中的属性和方法&lt;/h2&gt;
&lt;p&gt;我们利用 Person 构造器函数创建一个对象 jack ，就可以访问到原型中的方法了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var jack = new Person(&#39;jack&#39;);
jack.getName();//自身方法
&amp;gt;my name isjack 

jack.name//自身属性
&quot;jack&quot;

jack.color//原型属性
&amp;gt;&quot;white&quot;

jack.say(&#39;hello&#39;)//原型方法
&amp;gt;i say : hello 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;自身属性与原型属性&lt;/h2&gt;

&lt;p&gt;上面的demo中可以发现 jack 可以访问到自身属性和原型属性。
所谓自身属性是指在构造器中函数中定义的属性，原型属性则是在原型中定义的方法，如上例。
当我们访问某个属性的时候， JavaScript 会遍历对象的所有属性，如果找到就返回；如果找不到就去查询创建当前对象的构造器函数的原型，如果原型中找到，就立即返回，否则返回undefined，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jack.color//原型方法
&amp;gt;&quot;white&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;利用自身属性重写原型属性&lt;/h2&gt;

&lt;p&gt;弄清楚了自身属性和原型属性的区别之后，我们会想到这样一个问题：如果对象自身属性和原型属性同名怎么办？
先说答案：对象自身属性的优先级高于原型属性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(name){
	this.name = name;
	this.getName = function(){
		console.log(&#39;my name is &#39; + this.name) ;
	}
}

Person.prototype = {
	color : &#39;white&#39;,
	say : function(words){
		console.log(&#39;i say : &#39;+words)
	}
}

Person.prototype.name = &#39;fool&#39;;

var jack = new Person(&#39;jack&#39;);

jack.name
&amp;gt;&quot;jack&quot;

delete jack.name
jack.name
&amp;gt;&quot;fool&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到在原型中有name属性，自身属性也有name属性，对象会取对象的name属性，而不是原型中的。
有了这个特性之后，我们就可以利用构造器来重写原型中的属性了。&lt;/p&gt;

&lt;h2 id=&quot;isprototypeof&quot;&gt;isPrototypeOf()方法&lt;/h2&gt;

&lt;p&gt;每个对象中都有一个 isPrototypeOf() 方法，这个方法告诉我们当前对象是否是另一个对象的原型。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(name){
	this.name = name;
	this.getName = function(){
		console.log(&#39;my name is &#39; + this.name) ;
	}
}

var proto = {
	color : &#39;white&#39;,
	say : function(words){
		console.log(&#39;i say : &#39;+words)
	}
}

Person.prototype = proto;

var jack  =new Person(&#39;jack&#39;);
proto.isPrototypeOf(jack)
&amp;gt;true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;proto-&quot;&gt;&lt;strong&gt;__proto&lt;/strong&gt;__ 链接&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;__proto&lt;/strong&gt;__ ： 对象中存在一个指向相关原型的链接，这个链接在ff中被叫做 &lt;strong&gt;__proto&lt;/strong&gt;__ 。&lt;/p&gt;

&lt;p&gt;看个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(name){
	this.name = name;
	this.getName = function(){
		console.log(&#39;my name is &#39; + this.name) ;
	}
}

var proto = {
	color : &#39;white&#39;,
	say : function(words){
		console.log(&#39;i say : &#39;+words)
	}
}

Person.prototype = proto;

var jack  =new Person(&#39;jack&#39;);

jack.color
&amp;gt;&#39;white&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Person 中没有color属性，JavaScript就到原型中去寻找color属性；那么这就意味着我们可以从对象jack中获取原型对象。具体做法是把
构造器作为一个中转站， 执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jack.constructor.prototype 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就可以调用。
我们现在把这个中转站重写了，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jack.constructor = &#39;str&#39;

typeof jack.constructor.prototype
&amp;gt;&quot;undefined&quot;

jack.color //原型属性
&amp;gt;&quot;white&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以发现原型和jack的关系已经被我们打乱了，但是 jack.color 还是可以访问到原型中的属性值，这说明对象中有个隐形链接指向原型，这个就是 &lt;strong&gt;__proto&lt;/strong&gt;__&lt;/p&gt;

&lt;p&gt;需要说明的是，该属性在ie浏览器中是不存在的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__proto&lt;/strong&gt;__ 与 prototype并不是等价的。 &lt;strong&gt;__proto&lt;/strong&gt;__ 实际上是某个实体对象的属性 ，而 prototype则是属于构造器函数的属性。
&lt;strong&gt;__proto&lt;/strong&gt;__只能在调试环境下使用。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>收藏夹</title>
   <link href="/2015/02/05/collection/"/>
   <updated>2015-02-05T00:00:00+08:00</updated>
   <id>/2015/02/05/collection</id>
   <content type="html">
&lt;h1 id=&quot;section&quot;&gt;常用工具收藏&lt;/h1&gt;

&lt;h2 id=&quot;cdn&quot;&gt;1 CDN&lt;/h2&gt;

&lt;p&gt;开放静态文件 CDN新增一个库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.staticfile.org/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;supervisor&quot;&gt;2 supervisor&lt;/h2&gt;

&lt;p&gt;当修改了node代码或者node服务器挂了，可以自动重启node服务器的神器&lt;/p&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install supervisor -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;supervisor server.js ##原来的 node server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;详细参数 参见&lt;a href=&quot;https://github.com/isaacs/node-supervisor/&quot;&gt;https://github.com/isaacs/node-supervisor/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>ajax 页面恢复上次离开的是的历史记录</title>
   <link href="/2015/02/05/ajax-page-history/"/>
   <updated>2015-02-05T00:00:00+08:00</updated>
   <id>/2015/02/05/ajax-page-history</id>
   <content type="html">
&lt;p&gt;对于单页面应用（spa），页面内的操作基本上都是ajax，ajax页面内操作不会导致浏览器地址栏发生变化，要ajax页面的操作状态记忆需要特殊方式。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;思路：把页面上操作记录都存储下来，等回到页面再根据之前存储的值恢复页面状态&lt;/h2&gt;
&lt;p&gt;在存储介质上，我们可以选择前端介质，比如localstorage、cookie,或者手动维护一个js对象来存储，但是页面刷新之后变量就会丢失值，还可以选择后端存储。&lt;/p&gt;

&lt;p&gt;存储介质的选择不同，但是思路都一样 —- 页面上每个操作的状态都记录下来，恢复的时候利用之前存储的状态还原即可。下面逐一分析这些介质的特点：&lt;/p&gt;

&lt;h3 id=&quot;localstorage&quot;&gt;localstorage&lt;/h3&gt;

&lt;p&gt;兼容！痛。作为存储介质肯定没有问题，唯一的问题是兼容性，html5特性并不完全兼容所有浏览器，如果项目不考虑兼容性，这个是可以考虑的。&lt;/p&gt;

&lt;h3 id=&quot;cookie&quot;&gt;cookie&lt;/h3&gt;
&lt;p&gt;太珍贵了！cookie没有兼容问题，但是cookie存储的量不大，一般不推荐。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;后端存储&lt;/h3&gt;
&lt;p&gt;后端把状态缓存起来，这种模式太重了。&lt;/p&gt;

&lt;h3 id=&quot;locationhash&quot;&gt;location.hash存储&lt;/h3&gt;
&lt;p&gt;通常我们单页面应用不会改变url，防止页面刷新的。但是我们可以利用hash的特点来实现。
注意到浏览器的地址栏通常是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://xxx.com/#route1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;改变#之后的内容不会引起浏览器行为，除非你绑定了onhashchange函数。我们的思路就是把页面操作过程都存到hash中，在浏览器地址栏里面记录这些历史操作。把页面内的操作都存到hash中，当页面跳转的时候，把这些hash带着，目的是为了跳回来的时候，把这些参数带着，这样就可以解析历史操作了。&lt;/p&gt;

&lt;p&gt;为此需要准备一些基本工具—-解析和拼接url中hash的值&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;#&lt;/h3&gt;
&lt;p&gt;1 解析hash值的参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define([],function () {

    return function(){
        var hash = location.hash,
            hashArr,
            queryObj = {},
            queryArr = [];
        if(hash.indexOf(&#39;&amp;amp;&#39;)==-1){
            return queryObj;
        }
        hashArr = hash.split(&#39;&amp;amp;&#39;);
        hashArr.shift();
        _.each(hashArr,function(e){
            queryArr = e.split(&#39;=&#39;);
            queryObj[queryArr[0]] = queryArr[1];
        });
        return queryObj;
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2 拼接hash参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define([],function () {

    return function(queryParam){
        var paramStr = &#39;&#39;,
            rstHref = &#39;&#39;;
        if(queryParam=={}){
            return rstHref;
        }
        for(var i in queryParam){
            paramStr += &#39;&amp;amp;&#39;+i+&#39;=&#39;+queryParam[i];
        }
        rstHref =  paramStr;
        return rstHref;
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;浏览器hash值类似这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://127.0.0.1/center#route/price/monitor/queryDetailSummery?category=&amp;amp;ptBrand=&amp;amp;durativeIndex=&amp;amp;dataDate=2015-02-05&amp;amp;currentPage=1&amp;amp;pageSize=10&amp;amp;isWarn=1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解析后的值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object
	category: &quot;&quot;
	currentPage: 1
	dataDate: &quot;2015-02-05&quot;
	durativeIndex: &quot;&quot;
	isWarn: 1
	pageSize: 10
	ptBrand: &quot;&quot;
	__proto__: Object
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中 #route/price/monitor/queryDetailSummery? 这段代码是页面路由，与参数无关。&lt;/p&gt;

&lt;p&gt;这样做也有它的劣势，当过多页面需要记住操作历史的时候，可能存在页面间参数重名的问题、浏览器内容过长的问题等。如果少量页面间跳转需要记录历史，比如列表页跳转到详情页，这样的场景还是比较适用的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Windows 安装  jekyll</title>
   <link href="/2015/02/04/windows-setup-jetyll/"/>
   <updated>2015-02-04T00:00:00+08:00</updated>
   <id>/2015/02/04/windows-setup-jetyll</id>
   <content type="html">
&lt;p&gt;国内安装基于ruby的组件都是很痛苦的一件事情，你懂得！那只好曲线救国了。
先安装ruby，如果你没安装，请猛戳&lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;http://rubyinstaller.org/downloads/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打开CMD，正常安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install jekyll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;报错了是正常的，这是我们把ruby的源指向国内淘宝的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem sources --remove http://rubygems.org/
sudo gem sources -a http://ruby.taobao.org/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;windows下安装还是需要 DevKit。DevKit 是一个在 Windows 上帮助简化安装及使用 Ruby C/C++ 扩展如 RDiscount 和 RedCloth 的工具箱。 详细的安装指南可以在程序的 wiki 页面 阅读。&lt;/p&gt;

&lt;p&gt;再次前往 &lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;http://rubyinstaller.org/downloads/&lt;/a&gt;
下载同系统及 Ruby 版本相对应的 DevKit 安装包。 例如，DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe 适用于64位 Windows 系统上的 Ruby 2.0.0 x64。
下面列出了如何选择正确的 DevKit 版本：
Ruby 1.8.6 to 1.9.3: DevKit tdm-32-4.5.2
Ruby 2.0.0: DevKit mingw64-32-4.7.2
Ruby 2.0.0 x64: DevKit mingw64-64-4.7.2
运行安装包并解压缩至某文件夹，如 C:\DevKit
通过初始化来创建 config.yml 文件。在命令行窗口内，输入下列命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd “C:\DevKit”
ruby dk.rb init
notepad config.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在打开的记事本窗口中，于末尾添加新的一行 - C:\Ruby200-x64，保存文件并退出。
回到命令行窗口内，审查（非必须）并安装。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruby dk.rb review
ruby dk.rb install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;jekyll&quot;&gt;安装 Jekyll&lt;/h2&gt;

&lt;p&gt;确保 gem 已经正确安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出示例：
2.0.14
安装 Jekyll gem&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install jekyll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还有其他坑，比如要求ruby gem 1.9+的版本，低版本的请到官网升级。&lt;/p&gt;

&lt;p&gt;当然安装jetyll只是为了能在本地预览博客。如果不想安装的话，也可以，大不了每次都push到github，在那里预览。
这里介绍一个快速构建博客的框架，请猛戳&lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-quick-start.html&quot;&gt;jJekyll-Bootstrap&lt;/a&gt;，进入页面之后，根据提示来操作吧，剩下的就很简单了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>sass 安装</title>
   <link href="/2015/02/04/sass-setup/"/>
   <updated>2015-02-04T00:00:00+08:00</updated>
   <id>/2015/02/04/sass-setup</id>
   <content type="html">
&lt;p&gt;sass 运行依赖于ruby，以前安装的时候也存在一些坑，贴出来，希望看到的人可以绕过去。&lt;/p&gt;

&lt;h1 id=&quot;ruby&quot;&gt;1安装ruby&lt;/h1&gt;
&lt;p&gt;此处省略
#2安装sass
正常安装方式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem install sass
$ gem install compass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通常这样是安装不上的，你懂得。&lt;/p&gt;

&lt;p&gt;曲线救国吧，把ruby的源改为国内淘宝镜像。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem sources --remove https://rubygems.org/
$ gem sources -a https://ruby.taobao.org/
$ gem sources -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后再指向正常安装的指令就ok了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jekyll Bootstrap 如何去除页面上Disqus评论框架的Discovery box部分</title>
   <link href="/2015/02/04/jekyll-remove-comments-adds/"/>
   <updated>2015-02-04T00:00:00+08:00</updated>
   <id>/2015/02/04/jekyll-remove-comments-adds</id>
   <content type="html">
&lt;p&gt;Jekyll Bootstrap的评论功能是有Disqus提供的服务。我们的博客想要评论功能，但是不想要广告。
下面就介绍怎么把广告去掉。&lt;/p&gt;

&lt;h1 id=&quot;disqus&quot;&gt;注册Disqus&lt;/h1&gt;
&lt;p&gt;首先先登陆disqus.com，注册一个自己的服务，记住自己的short_name，可以在设置页面查看到。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://USERNAME.disqus.com/admin/settings/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;configyml&quot;&gt;修改_config.yml配置&lt;/h1&gt;
&lt;p&gt;comments的默认配置是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;comments :
provider : disqus
disqus :
  short_name : jekyllbootstrap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为此我们需要修改为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;comments :
provider : disqus
disqus :
  short_name : USERNAME  #这就是你在disqus的short_name
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到此，问题就解决了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>jekyll 常用命令</title>
   <link href="/2015/02/04/jekyll-commend/"/>
   <updated>2015-02-04T00:00:00+08:00</updated>
   <id>/2015/02/04/jekyll-commend</id>
   <content type="html">
&lt;h2 id=&quot;jetyll&quot;&gt;安装jetyll&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;jetyll-1&quot;&gt;启动jetyll&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll serve
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;新增一篇文章&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rake post title=&quot;Hello World&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;新增一个页面&lt;/h2&gt;
&lt;p&gt;创建一个简单的页面&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rake page name=&quot;about.md&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建一个嵌套页面&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rake page name=&quot;pages/about.md&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建一个带路径的页面&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rake page name=&quot;pages/about&quot;
# this will create the file: ./pages/about/index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 
</feed>
